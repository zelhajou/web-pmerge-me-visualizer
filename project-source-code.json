{
  "src/App.css": "/* Developer-focused UI styles */\n\n/* Base styles */\nbody {\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n  line-height: 1.5;\n  color: #333;\n}\n\n/* Button styles - clean and functional */\nbutton {\n  cursor: pointer;\n  font-size: 14px;\n  border: none;\n  border-radius: 4px;\n  transition: background-color 0.2s, transform 0.1s;\n}\n\nbutton:active {\n  transform: translateY(1px);\n}\n\nbutton:focus {\n  outline: 2px solid rgba(59, 130, 246, 0.5);\n  outline-offset: 1px;\n}\n\n/* Code blocks */\npre, code {\n  font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, monospace;\n  font-size: 13px;\n}\n\n.code-block {\n  background-color: #f8f8f8;\n  border: 1px solid #e8e8e8;\n  border-radius: 4px;\n  overflow-x: auto;\n}\n\n/* Input fields */\ninput {\n  border: 1px solid #d1d5db;\n  border-radius: 4px;\n  padding: 8px 12px;\n  font-size: 14px;\n}\n\ninput:focus {\n  border-color: #3b82f6;\n  outline: none;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);\n}\n\n/* Readable typography */\nh1 {\n  font-size: 24px;\n  font-weight: 600;\n  margin-bottom: 8px;\n}\n\nh2 {\n  font-size: 20px;\n  font-weight: 600;\n  margin-bottom: 8px;\n}\n\nh3 {\n  font-size: 16px;\n  font-weight: 600;\n  margin-bottom: 8px;\n}\n\np {\n  margin-bottom: 16px;\n}\n\n/* Card styles */\n.card {\n  border: 1px solid #e5e7eb;\n  border-radius: 6px;\n  overflow: hidden;\n  background-color: white;\n}\n\n.card-header {\n  background-color: #f3f4f6;\n  padding: 12px 16px;\n  font-weight: 600;\n  border-bottom: 1px solid #e5e7eb;\n}\n\n.card-body {\n  padding: 16px;\n}\n\n/* Table styles for data display */\ntable {\n  width: 100%;\n  border-collapse: collapse;\n}\n\nth, td {\n  padding: 8px 12px;\n  text-align: left;\n  border-bottom: 1px solid #e5e7eb;\n}\n\nth {\n  background-color: #f3f4f6;\n  font-weight: 600;\n}\n\n/* Memory state visualization */\n.memory-item {\n  display: inline-flex;\n  flex-direction: column;\n  align-items: center;\n  margin-right: 4px;\n  margin-bottom: 4px;\n}\n\n.memory-value {\n  padding: 4px 8px;\n  background-color: #e5e7eb;\n  border-radius: 4px;\n  font-family: monospace;\n}\n\n.memory-index {\n  font-size: 11px;\n  color: #6b7280;\n  margin-top: 2px;\n}\n\n/* Monospace text for data */\n.monospace {\n  font-family: monospace;\n}\n\n/* Utility classes */\n.text-center {\n  text-align: center;\n}\n\n.mb-1 { margin-bottom: 4px; }\n.mb-2 { margin-bottom: 8px; }\n.mb-3 { margin-bottom: 12px; }\n.mb-4 { margin-bottom: 16px; }\n\n.mt-1 { margin-top: 4px; }\n.mt-2 { margin-top: 8px; }\n.mt-3 { margin-top: 12px; }\n.mt-4 { margin-top: 16px; }\n\n.p-1 { padding: 4px; }\n.p-2 { padding: 8px; }\n.p-3 { padding: 12px; }\n.p-4 { padding: 16px; }\n\n/* Responsive adjustments */\n@media (max-width: 768px) {\n  .lg\\:col-span-1, .lg\\:col-span-2 {\n    grid-column: span 1;\n  }\n  \n  .lg\\:order-1 {\n    order: 1;\n  }\n  \n  .lg\\:order-2 {\n    order: 2;\n  }\n  \n  .container {\n    padding-left: 12px;\n    padding-right: 12px;\n  }\n}",
  "src/App.js": "import React, { useState } from 'react';\nimport { useAlgorithm } from './hooks/useAlgorithm';\nimport { usePlayback } from './hooks/usePlayback';\nimport { AlgorithmControls } from './components/Algorithm';\nimport AlgorithmStepDetail from './components/Algorithm/AlgorithmStepDetail';\nimport AlgorithmComparison from './components/AlgorithmComparison';\nimport CppImplementation from './components/CppImplementation';\nimport { \n  CodeVisualization, \n  MemoryStateVisualization, \n  CallStackVisualization \n} from './components/Visualization';\n\nconst App = () => {\n  // Get the initial input array from the URL or use default\n  const urlParams = new URLSearchParams(window.location.search);\n  const urlArray = urlParams.get('array');\n  const initialArray = urlArray \n    ? urlArray.split(',').map(num => parseInt(num.trim())) \n    : [5, 3, 8, 2, 1, 9, 4];\n  \n  // State\n  const [showCppImplementation, setShowCppImplementation] = useState(false);\n  \n  // Use the custom hooks\n  const { \n    inputArray,\n    setInputArray,\n    currentStep, \n    currentStepData, \n    executionSteps, \n    setCurrentStep,\n    processNewInput \n  } = useAlgorithm(initialArray);\n  \n  const { \n    isPlaying, \n    playbackSpeed, \n    setPlaybackSpeed, \n    togglePlayback, \n    goToFirstStep, \n    goToLastStep, \n    goToNextStep, \n    goToPrevStep \n  } = usePlayback(currentStep, setCurrentStep, executionSteps.length);\n\n  // Handle input change\n  const handleInputChange = (e) => {\n    const input = e.target.value.split(',').map(num => parseInt(num.trim()));\n    if (input.every(num => !isNaN(num))) {\n      setInputArray(input);\n      processNewInput(input);\n      \n      // Update URL for sharing\n      const url = new URL(window.location);\n      url.searchParams.set('array', input.join(','));\n      window.history.pushState({}, '', url);\n    }\n  };\n\n  // Random array generator\n  const generateRandomArray = () => {\n    const length = Math.floor(Math.random() * 6) + 5; // 5-10 elements\n    const randomArray = Array.from({ length }, () => Math.floor(Math.random() * 100));\n    setInputArray(randomArray);\n    processNewInput(randomArray);\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gray-50\">\n      <main className=\"container mx-auto px-4 py-6\">\n        {/* Header */}\n        <div className=\"mb-6\">\n          <h1 className=\"text-3xl font-bold text-gray-800\">\n            Ford-Johnson Algorithm Visualizer\n          </h1>\n          <p className=\"text-gray-600 mt-2\">\n            A step-by-step visualization of the merge-insert sort algorithm\n          </p>\n        </div>\n\n        {/* Action buttons - simple and functional */}\n        <div className=\"flex flex-wrap gap-3 mb-6\">\n          <button\n            onClick={generateRandomArray}\n            className=\"px-4 py-2 bg-blue-600 text-white font-medium rounded hover:bg-blue-700\"\n            title=\"Generate random array for testing\"\n          >\n            Random Array\n          </button>\n          <button\n            onClick={() => setShowCppImplementation(!showCppImplementation)}\n            className=\"px-4 py-2 bg-gray-200 text-gray-800 font-medium rounded hover:bg-gray-300\"\n          >\n            {showCppImplementation ? \"Hide C++ Code\" : \"View C++ Code\"}\n          </button>\n        </div>\n\n        {/* C++ Implementation Component (conditionally rendered) */}\n        {showCppImplementation && <CppImplementation />}\n        \n        {/* Algorithm Controls */}\n        <div className=\"bg-white rounded-lg shadow mb-6 p-4\">\n          <AlgorithmControls \n            inputArray={inputArray}\n            handleInputChange={handleInputChange}\n            playbackSpeed={playbackSpeed}\n            setPlaybackSpeed={setPlaybackSpeed}\n            isPlaying={isPlaying}\n            togglePlayback={togglePlayback}\n            goToFirstStep={goToFirstStep}\n            goToLastStep={goToLastStep}\n            goToNextStep={goToNextStep}\n            goToPrevStep={goToPrevStep}\n            currentStep={currentStep}\n            totalSteps={executionSteps.length}\n          />\n        </div>\n        \n        {/* Step Information Header */}\n        <AlgorithmStepDetail \n          step={currentStepData}\n          currentStep={currentStep}\n          totalSteps={executionSteps.length}\n        />\n        \n        {/* Main Content Area */}\n        <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-4 mb-8 mt-4\">\n          {/* Left Column: Code and Call Stack Panel */}\n          <div className=\"lg:col-span-1 order-2 lg:order-1 space-y-4\">\n            {/* Code Visualization */}\n            <CodeVisualization code={currentStepData.code} />\n            \n            {/* Call Stack Visualization */}\n            <CallStackVisualization callStack={currentStepData.callStack} />\n            \n            {/* Algorithm Information Panel */}\n            <div id=\"algo-info\" className=\"border rounded-lg overflow-hidden shadow bg-white\">\n              <div className=\"bg-gray-100 px-4 py-3 font-semibold border-b\">\n                Algorithm Documentation\n              </div>\n              <div className=\"p-4\">\n                <h3 className=\"font-semibold text-lg text-gray-800 mb-3\">Ford-Johnson (Merge-Insert Sort)</h3>\n                <p className=\"text-gray-700 mb-4\">\n                  This algorithm combines merge sort and insertion sort techniques to achieve optimal\n                  comparison efficiency, using the Jacobsthal sequence for insertion order.\n                </p>\n                \n                <h4 className=\"font-semibold text-gray-700 mt-4 mb-2\">Key Phases:</h4>\n                <ul className=\"list-disc list-inside space-y-1 text-gray-700\">\n                  <li>Pair formation from consecutive elements</li>\n                  <li>Recursively sort the main chain (larger elements)</li>\n                  <li>Insert remaining elements using binary search</li>\n                  <li>Use Jacobsthal numbers to optimize insertion sequence</li>\n                </ul>\n                \n                <div className=\"mt-4 p-3 bg-gray-100 rounded text-sm\">\n                  <span className=\"font-semibold\">Time Complexity:</span> O(n log n)\n                </div>\n              </div>\n            </div>\n            \n            {/* Algorithm Comparison */}\n            {/* <AlgorithmComparison /> */}\n          </div>\n          \n          {/* Right Column: Memory State Visualization */}\n          <div className=\"lg:col-span-2 order-1 lg:order-2\">\n            <MemoryStateVisualization memoryState={currentStepData.memoryState} />\n          </div>\n        </div>\n      </main>\n\n      {/* Simple footer */}\n      <footer className=\"bg-gray-800 text-white py-4 text-center text-sm\">\n        <p>PmergeMe Visualizer - Ford-Johnson Algorithm Implementation</p>\n      </footer>\n    </div>\n  );\n};\n\nexport default App;",
  "src/App.test.js": "import { render, screen } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  render(<App />);\n  const linkElement = screen.getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n",
  "src/ExamplePage.js": "import React, { useState } from 'react';\nimport FordJohnsonVisualizer from './components/FordJohnsonVisualizer';\nimport FordJohnsonDemo from './components/FordJohnsonDemo';\n\n/**\n * Example page that showcases both the full visualizer and simplified demo\n */\nconst ExamplePage = () => {\n  const [view, setView] = useState('demo'); // 'visualizer' or 'demo'\n  const [array, setArray] = useState([5, 3, 8, 2, 1, 9, 4]);\n  \n  // Handle array input change\n  const handleArrayChange = (e) => {\n    try {\n      const inputArray = e.target.value.split(',').map(num => parseInt(num.trim()));\n      if (inputArray.every(num => !isNaN(num))) {\n        setArray(inputArray);\n      }\n    } catch (error) {\n      console.error(\"Invalid array input:\", error);\n    }\n  };\n  \n  return (\n    <div className=\"container mx-auto p-4\">\n      <h1 className=\"text-3xl font-bold mb-6\">Ford-Johnson Algorithm Visualization</h1>\n      \n      {/* Array input for both views */}\n      <div className=\"mb-6\">\n        <label className=\"block text-sm font-medium text-gray-700 mb-1\">\n          Test Array:\n        </label>\n        <div className=\"flex\">\n          <input\n            type=\"text\"\n            className=\"flex-1 px-3 py-2 border rounded-l-md\"\n            value={array.join(', ')}\n            onChange={handleArrayChange}\n            placeholder=\"Enter numbers separated by commas\"\n          />\n          <button\n            onClick={() => setArray([...array].sort(() => Math.random() - 0.5))}\n            className=\"px-4 py-2 bg-indigo-100 text-indigo-800 rounded-r-md hover:bg-indigo-200\"\n            title=\"Randomize array\"\n          >\n            Shuffle\n          </button>\n        </div>\n      </div>\n      \n      {/* View selector */}\n      <div className=\"mb-6\">\n        <div className=\"flex space-x-4\">\n          <button\n            className={`px-4 py-2 rounded-md ${view === 'demo' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}\n            onClick={() => setView('demo')}\n          >\n            Simple Demo\n          </button>\n          <button\n            className={`px-4 py-2 rounded-md ${view === 'visualizer' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}\n            onClick={() => setView('visualizer')}\n          >\n            Full Visualizer\n          </button>\n        </div>\n      </div>\n      \n      {/* View description */}\n      <div className=\"mb-4 p-4 bg-gray-50 rounded-md\">\n        {view === 'demo' ? (\n          <div>\n            <h2 className=\"text-xl font-bold mb-2\">Simple Demo Mode</h2>\n            <p>\n              This is a simplified demonstration of the Ford-Johnson algorithm, designed to show the key \n              steps without overwhelming detail. Perfect for getting a quick understanding of how the \n              algorithm works.\n            </p>\n          </div>\n        ) : (\n          <div>\n            <h2 className=\"text-xl font-bold mb-2\">Full Visualizer Mode</h2>\n            <p>\n              This is the comprehensive Ford-Johnson Algorithm Visualizer that shows every step in detail, \n              including memory state, call stack, and all operations. Ideal for in-depth learning and \n              algorithm analysis.\n            </p>\n          </div>\n        )}\n      </div>\n      \n      {/* Render the selected component */}\n      {view === 'demo' ? (\n        <FordJohnsonDemo initialArray={array} />\n      ) : (\n        <FordJohnsonVisualizer initialArray={array} />\n      )}\n      \n      {/* Additional information */}\n      <div className=\"mt-8 p-4 bg-blue-50 rounded-md\">\n        <h2 className=\"text-xl font-bold mb-2\">About Ford-Johnson Algorithm</h2>\n        <p className=\"mb-4\">\n          The Ford-Johnson algorithm, also known as merge-insertion sort, is a comparison sorting algorithm \n          designed to minimize the number of comparisons required to sort an array. It was first described \n          by L. Ford and S. Johnson in 1959.\n        </p>\n        <p>\n          This algorithm is notable for approaching the information-theoretic lower bound on the number of \n          comparisons needed, making it theoretically more efficient than many common sorting algorithms in \n          terms of comparison count (though not necessarily in terms of overall performance due to other factors).\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default ExamplePage;",
  "src/components/Algorithm/AlgorithmControls.js": "import React from 'react';\nimport { ChevronLeft, ChevronRight, SkipBack, SkipForward, Play, Pause } from 'lucide-react';\n\nconst AlgorithmControls = ({\n  inputArray,\n  handleInputChange,\n  playbackSpeed,\n  setPlaybackSpeed,\n  isPlaying,\n  togglePlayback,\n  goToFirstStep,\n  goToLastStep,\n  goToNextStep,\n  goToPrevStep,\n  currentStep,\n  totalSteps\n}) => {\n  return (\n    <div className=\"mb-6 p-4 bg-gray-50 rounded-md shadow-sm\">\n      <div className=\"flex flex-col md:flex-row md:items-center gap-4\">\n        <div className=\"flex-1\">\n          <label className=\"block text-sm font-medium text-gray-700 mb-1\">Input Array:</label>\n          <input\n            type=\"text\"\n            className=\"w-full px-3 py-2 border rounded-md\"\n            value={inputArray.join(', ')}\n            onChange={handleInputChange}\n            placeholder=\"Enter numbers separated by commas\"\n          />\n          <p className=\"text-xs text-gray-500 mt-1\">Example: 5, 3, 8, 2, 1, 9, 4</p>\n        </div>\n        <div>\n          <label className=\"block text-sm font-medium text-gray-700 mb-1\">Playback Speed:</label>\n          <select\n            className=\"px-3 py-2 border rounded-md\"\n            value={playbackSpeed}\n            onChange={(e) => setPlaybackSpeed(parseFloat(e.target.value))}\n          >\n            <option value=\"0.5\">0.5x</option>\n            <option value=\"1\">1x</option>\n            <option value=\"1.5\">1.5x</option>\n            <option value=\"2\">2x</option>\n            <option value=\"3\">3x</option>\n          </select>\n        </div>\n      </div>\n      \n      {/* Navigation controls */}\n      <div className=\"flex justify-center items-center mt-4 gap-2\">\n        <button \n          onClick={goToFirstStep}\n          className=\"p-2 bg-gray-100 hover:bg-gray-200 rounded-md\"\n          title=\"First Step\"\n        >\n          <SkipBack size={18} />\n        </button>\n        <button \n          onClick={goToPrevStep}\n          className=\"p-2 bg-gray-100 hover:bg-gray-200 rounded-md\"\n          title=\"Previous Step\"\n          disabled={currentStep === 0}\n        >\n          <ChevronLeft size={18} />\n        </button>\n        <button \n          onClick={togglePlayback}\n          className=\"p-2 bg-blue-100 hover:bg-blue-200 text-blue-800 rounded-md flex items-center gap-1 px-3\"\n        >\n          {isPlaying ? <Pause size={18} /> : <Play size={18} />}\n          <span>{isPlaying ? \"Pause\" : \"Play\"}</span>\n        </button>\n        <button \n          onClick={goToNextStep}\n          className=\"p-2 bg-gray-100 hover:bg-gray-200 rounded-md\"\n          title=\"Next Step\"\n          disabled={currentStep === totalSteps - 1}\n        >\n          <ChevronRight size={18} />\n        </button>\n        <button \n          onClick={goToLastStep}\n          className=\"p-2 bg-gray-100 hover:bg-gray-200 rounded-md\"\n          title=\"Last Step\"\n        >\n          <SkipForward size={18} />\n        </button>\n        <div className=\"ml-4 text-sm text-gray-700\">\n          Step {currentStep + 1} of {totalSteps}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default AlgorithmControls;",
  "src/components/Algorithm/AlgorithmProgress.js": "import React from 'react';\n\nconst AlgorithmProgress = ({ currentStep, totalSteps }) => {\n  const progress = ((currentStep + 1) / totalSteps) * 100;\n  \n  return (\n    <div className=\"w-full bg-gray-200 rounded-full h-2.5\">\n      <div \n        className=\"bg-blue-600 h-2.5 rounded-full\" \n        style={{ width: `${progress}%` }}\n      ></div>\n    </div>\n  );\n};\n\nexport default AlgorithmProgress;",
  "src/components/Algorithm/AlgorithmStepDetail.js": "import React from 'react';\n\nconst AlgorithmStepDetail = ({ step, currentStep, totalSteps }) => {\n  if (!step) return null;\n  \n  // Calculate progress percentage\n  const progress = ((currentStep + 1) / totalSteps) * 100;\n  \n  // Format the step title with algorithm phase indicators\n  const formatTitle = (title) => {\n    // Check for specific algorithm phases\n    const phases = {\n      'Initial Input': 'start',\n      'Handle Odd-sized': 'straggler',\n      'Form Pairs': 'pairs',\n      'Sort Within Pairs': 'sort-pairs',\n      'Extract Main Chain': 'extract',\n      'Recursive': 'recursion',\n      'Insert': 'insert',\n      'Return': 'return'\n    };\n    \n    // Find matching phase\n    let phaseKey = Object.keys(phases).find(key => title.includes(key));\n    const phase = phaseKey ? phases[phaseKey] : 'other';\n    \n    // Apply color based on phase\n    const phaseColors = {\n      'start': 'blue',\n      'straggler': 'yellow',\n      'pairs': 'purple',\n      'sort-pairs': 'indigo',\n      'extract': 'green',\n      'recursion': 'red',\n      'insert': 'pink',\n      'return': 'teal',\n      'other': 'gray'\n    };\n    \n    const color = phaseColors[phase];\n    \n    return (\n      <div className=\"flex items-center\">\n        <div className={`w-2 h-2 rounded-full bg-${color}-500 mr-2`}></div>\n        <h2 className=\"text-xl font-bold text-gray-800\">{title}</h2>\n      </div>\n    );\n  };\n  \n  return (\n    <div className=\"bg-white border rounded-t-md p-4 flex flex-col gap-4 shadow-sm\">\n      <div className=\"flex-1\">\n        {formatTitle(step.title)}\n        <p className=\"text-gray-600 mt-1\">{step.description}</p>\n        \n        {/* Algorithm phase indicator */}\n        <div className=\"mt-2\">\n          <div className=\"flex justify-between text-xs text-gray-500 mb-1\">\n            <span>Start</span>\n            <span>Pair Formation</span>\n            <span>Main Chain</span>\n            <span>Insertion</span>\n            <span>Complete</span>\n          </div>\n          <div className=\"w-full bg-gray-200 rounded-full h-2.5\">\n            <div \n              className=\"bg-blue-600 h-2.5 rounded-full\" \n              style={{ width: `${progress}%` }}\n            ></div>\n          </div>\n          <div className=\"flex justify-between mt-1\">\n            <span className=\"text-xs font-medium text-blue-600\">\n              Step {currentStep + 1} of {totalSteps}\n            </span>\n            <span className=\"text-xs font-medium text-gray-500\">\n              {progress.toFixed(0)}% complete\n            </span>\n          </div>\n        </div>\n      </div>\n      \n      {/* Key operations for this step */}\n      {step.memoryState && step.memoryState.operations && step.memoryState.operations.length > 0 && (\n        <div className=\"mt-2 py-2 px-3 bg-blue-50 border border-blue-100 rounded-md\">\n          <h3 className=\"text-sm font-semibold text-blue-800 mb-1\">Key Operations:</h3>\n          <ul className=\"list-disc list-inside text-sm space-y-1\">\n            {step.memoryState.operations.map((operation, idx) => (\n              <li key={idx} className=\"text-gray-700\">{operation}</li>\n            ))}\n          </ul>\n        </div>\n      )}\n      \n      {/* Variable changes in this step */}\n      {step.memoryState && step.memoryState.changes && step.memoryState.changes.length > 0 && (\n        <div className=\"mt-2 py-2 px-3 bg-green-50 border border-green-100 rounded-md\">\n          <h3 className=\"text-sm font-semibold text-green-800 mb-1\">Variable Changes:</h3>\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-2\">\n            {step.memoryState.changes.map((change, idx) => (\n              <div key={idx} className=\"flex items-center text-sm\">\n                <span className=\"font-mono font-bold mr-2\">{change.variable}:</span>\n                <div className=\"flex items-center\">\n                  <span className=\"bg-red-100 line-through px-2 py-0.5 rounded mr-1 text-xs max-w-xs truncate\">\n                    {change.from}\n                  </span>\n                  <span className=\"text-green-600\">→</span>\n                  <span className=\"bg-green-100 px-2 py-0.5 rounded ml-1 text-xs max-w-xs truncate\">\n                    {change.to}\n                  </span>\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default AlgorithmStepDetail;",
  "src/components/Algorithm/AlgorithmStepInfo.js": "import React from 'react';\nimport AlgorithmProgress from './AlgorithmProgress';\n\nconst AlgorithmStepInfo = ({ title, description, currentStep, totalSteps }) => {\n  return (\n    <div className=\"bg-white border rounded-t-md p-4 flex flex-col md:flex-row gap-4 shadow-sm\">\n      <div className=\"flex-1\">\n        <h2 className=\"text-xl font-bold text-gray-800\">{title}</h2>\n        <p className=\"text-gray-600\">{description}</p>\n      </div>\n      <div className=\"md:w-1/3 lg:w-1/4 flex items-center\">\n        <AlgorithmProgress currentStep={currentStep} totalSteps={totalSteps} />\n      </div>\n    </div>\n  );\n};\n\nexport default AlgorithmStepInfo;",
  "src/components/Algorithm/index.js": "import AlgorithmControls from './AlgorithmControls';\nimport AlgorithmProgress from './AlgorithmProgress';\nimport AlgorithmStepInfo from './AlgorithmStepInfo';\n\nexport { AlgorithmControls, AlgorithmProgress, AlgorithmStepInfo };",
  "src/components/AlgorithmComparison.js": "import React, { useState, useEffect } from 'react';\n\nconst AlgorithmComparison = () => {\n  const [comparisonData, setComparisonData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  // Simulate calculation of comparison data\n  useEffect(() => {\n    // In a real implementation, you would run actual benchmarks\n    // Here we're just using representative data\n    setTimeout(() => {\n      setComparisonData({\n        algorithms: [\n          { name: 'Ford-Johnson (Merge-Insert)', comparisons: 'n log n - n/2', avg: 'O(n log n)', worst: 'O(n log n)', comparisonEfficiency: 95 },\n          { name: 'Merge Sort', comparisons: 'n log n', avg: 'O(n log n)', worst: 'O(n log n)', comparisonEfficiency: 80 },\n          { name: 'Quick Sort', comparisons: 'n log n', avg: 'O(n log n)', worst: 'O(n²)', comparisonEfficiency: 75 },\n          { name: 'Heap Sort', comparisons: 'n log n', avg: 'O(n log n)', worst: 'O(n log n)', comparisonEfficiency: 78 },\n          { name: 'Insertion Sort', comparisons: 'n²/4', avg: 'O(n²)', worst: 'O(n²)', comparisonEfficiency: 50 }\n        ],\n        benchmarks: [\n          { n: 10, fordJohnson: 24, mergeSort: 27, quickSort: 25, heapSort: 28, insertionSort: 31 },\n          { n: 100, fordJohnson: 567, mergeSort: 664, quickSort: 612, heapSort: 675, insertionSort: 2490 },\n          { n: 1000, fordJohnson: 9601, mergeSort: 11356, quickSort: 10521, heapSort: 11432, insertionSort: 249015 }\n        ],\n        insights: [\n          \"Ford-Johnson is designed to minimize the number of comparisons\",\n          \"It achieves nearly optimal worst-case efficiency for comparison-based sorting\",\n          \"Uses the Jacobsthal sequence to optimize insertion order\",\n          \"Particularly effective for scenarios where comparisons are expensive\"\n        ]\n      });\n      setLoading(false);\n    }, 1500);\n  }, []);\n  \n  if (loading) {\n    return (\n      <div className=\"border rounded-md overflow-hidden\">\n        <div className=\"bg-gray-100 px-4 py-2 font-semibold border-b\">\n          Algorithm Comparison\n        </div>\n        <div className=\"p-4 bg-white text-center\">\n          <div className=\"animate-pulse text-gray-500\">Loading comparison data...</div>\n        </div>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"border rounded-md overflow-hidden\">\n      <div className=\"bg-gray-100 px-4 py-2 font-semibold border-b\">\n        Algorithm Comparison\n      </div>\n      <div className=\"p-4 bg-white\">\n        <h3 className=\"font-semibold mb-3\">Comparison Efficiency</h3>\n        \n        {/* Efficiency bar chart */}\n        <div className=\"space-y-3 mb-6\">\n          {comparisonData.algorithms.map((algo) => (\n            <div key={algo.name} className=\"space-y-1\">\n              <div className=\"flex justify-between text-sm\">\n                <span>{algo.name}</span>\n                <span className=\"font-mono\">{algo.comparisons}</span>\n              </div>\n              <div className=\"w-full bg-gray-200 rounded-full h-2.5\">\n                <div \n                  className={`h-2.5 rounded-full ${algo.name.includes('Ford') ? 'bg-blue-600' : 'bg-gray-500'}`} \n                  style={{ width: `${algo.comparisonEfficiency}%` }}\n                ></div>\n              </div>\n              <div className=\"flex justify-end text-xs text-gray-500\">\n                {algo.comparisonEfficiency}% efficiency\n              </div>\n            </div>\n          ))}\n        </div>\n        \n        {/* Benchmark table */}\n        <h3 className=\"font-semibold mb-2\">Benchmark: Number of Comparisons</h3>\n        <div className=\"overflow-x-auto\">\n          <table className=\"min-w-full divide-y divide-gray-200\">\n            <thead className=\"bg-gray-50\">\n              <tr>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n                  Array Size\n                </th>\n                {comparisonData.algorithms.map((algo) => (\n                  <th key={algo.name} className=\"px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider\">\n                    {algo.name.split(' ')[0]}\n                  </th>\n                ))}\n              </tr>\n            </thead>\n            <tbody className=\"bg-white divide-y divide-gray-200\">\n              {comparisonData.benchmarks.map((benchmark) => (\n                <tr key={benchmark.n}>\n                  <td className=\"px-3 py-2 whitespace-nowrap font-medium\">\n                    n = {benchmark.n}\n                  </td>\n                  <td className=\"px-3 py-2 whitespace-nowrap font-mono text-blue-600\">\n                    {benchmark.fordJohnson}\n                  </td>\n                  <td className=\"px-3 py-2 whitespace-nowrap\">\n                    {benchmark.mergeSort}\n                  </td>\n                  <td className=\"px-3 py-2 whitespace-nowrap\">\n                    {benchmark.quickSort}\n                  </td>\n                  <td className=\"px-3 py-2 whitespace-nowrap\">\n                    {benchmark.heapSort}\n                  </td>\n                  <td className=\"px-3 py-2 whitespace-nowrap\">\n                    {benchmark.insertionSort}\n                  </td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n        \n        {/* Key insights */}\n        <div className=\"mt-4 p-3 bg-blue-50 rounded-md\">\n          <h3 className=\"font-semibold text-sm mb-2\">Key Insights</h3>\n          <ul className=\"list-disc list-inside text-sm space-y-1\">\n            {comparisonData.insights.map((insight, idx) => (\n              <li key={idx}>{insight}</li>\n            ))}\n          </ul>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default AlgorithmComparison;",
  "src/components/CppImplementation.js": "import React, { useState, useEffect } from 'react';\nimport { Code, Copy, Check, ExternalLink } from 'lucide-react';\n\nconst CppImplementation = () => {\n  const [copied, setCopied] = useState(false);\n  const [showFullCode, setShowFullCode] = useState(false);\n  const [highlightedCode, setHighlightedCode] = useState('');\n  const [isLoading, setIsLoading] = useState(true);\n\n  // The C++ implementation code\n  const cppCode = `\n// Ford-Johnson (Merge-Insert) Sort Implementation\nstd::vector<int> PmergeMe::getJacobsthalSequence(int n) {\n    std::vector<int> jacobsthal;\n    \n    jacobsthal.push_back(0);\n    if (n > 0)\n        jacobsthal.push_back(1);\n    \n    for (int i = 2; i <= n; i++) {\n        int next = jacobsthal[i-1] + 2 * jacobsthal[i-2];\n        jacobsthal.push_back(next);\n    }\n    \n    return jacobsthal;\n}\n\nvoid PmergeMe::sortVector() {\n    if (_vec.size() <= 1)\n        return;\n    \n    // Step 1: Handle odd-sized array\n    bool hasStraggler = false;\n    int straggler = 0;\n    \n    if (_vec.size() % 2 != 0) {\n        hasStraggler = true;\n        straggler = _vec.back();\n        _vec.pop_back();\n    }\n    \n    // Step 2: Form pairs from consecutive elements\n    std::vector<std::pair<int, int> > pairs;\n    for (size_t i = 0; i < _vec.size(); i += 2) {\n        int first = _vec[i];\n        int second = _vec[i + 1];\n        pairs.push_back(std::make_pair(first, second));\n    }\n    \n    // Step 3: Sort elements within pairs (larger element first)\n    for (size_t i = 0; i < pairs.size(); i++) {\n        if (pairs[i].first < pairs[i].second)\n            std::swap(pairs[i].first, pairs[i].second);\n    }\n    \n    // Step 4: Extract main chain (larger elements)\n    std::vector<int> mainChain;\n    for (size_t i = 0; i < pairs.size(); i++) {\n        mainChain.push_back(pairs[i].first);\n    }\n    \n    // Step 5: Recursively sort main chain\n    if (mainChain.size() > 1) {\n        _vec = mainChain;\n        sortVector();\n        mainChain = _vec;\n    }\n    \n    // Step 6: Initialize result with the first element from main chain\n    std::vector<int> result;\n    if (!mainChain.empty())\n        result.push_back(mainChain[0]);\n    \n    // Step 7: Insert first smaller element\n    if (!pairs.empty())\n        result.insert(result.begin(), pairs[0].second);\n    \n    // Step 8: For remaining elements, use Jacobsthal sequence\n    if (pairs.size() > 1) {\n        // Generate Jacobsthal sequence\n        int jacobsthalSize = 3;\n        while (getJacobsthalSequence(jacobsthalSize).back() < (int)pairs.size())\n            jacobsthalSize++;\n        \n        std::vector<int> jacobSeq = getJacobsthalSequence(jacobsthalSize);\n        \n        // Calculate insertion order\n        std::vector<int> insertionOrder;\n        std::vector<bool> inserted(pairs.size(), false);\n        inserted[0] = true; // Mark first pair as already processed\n        \n        for (size_t i = 1; i < jacobSeq.size() && jacobSeq[i] < (int)pairs.size(); i++) {\n            int idx = jacobSeq[i];\n            if (!inserted[idx]) {\n                insertionOrder.push_back(idx);\n                inserted[idx] = true;\n            }\n            \n            // Fill in between Jacobsthal numbers in descending order\n            for (int j = idx - 1; j > jacobSeq[i-1]; j--) {\n                if (j >= 0 && j < (int)pairs.size() && !inserted[j]) {\n                    insertionOrder.push_back(j);\n                    inserted[j] = true;\n                }\n            }\n        }\n        \n        // Add any remaining indices\n        for (size_t i = 1; i < pairs.size(); i++) {\n            if (!inserted[i])\n                insertionOrder.push_back(i);\n        }\n        \n        // Insert elements according to determined order\n        for (size_t i = 0; i < insertionOrder.size(); i++) {\n            int idx = insertionOrder[i];\n            \n            // Insert main chain element if not already in result\n            if (std::find(result.begin(), result.end(), mainChain[idx]) == result.end()) {\n                std::vector<int>::iterator pos = std::lower_bound(result.begin(), result.end(), mainChain[idx]);\n                result.insert(pos, mainChain[idx]);\n            }\n            \n            // Insert smaller element\n            std::vector<int>::iterator pos = std::lower_bound(result.begin(), result.end(), pairs[idx].second);\n            result.insert(pos, pairs[idx].second);\n        }\n    }\n    \n    // Step 9: Insert straggler if exists\n    if (hasStraggler) {\n        std::vector<int>::iterator pos = std::lower_bound(result.begin(), result.end(), straggler);\n        result.insert(pos, straggler);\n    }\n    \n    // Step 10: Set final result\n    _vec = result;\n}\n\n`;\n\n  // Function to handle copy to clipboard\n  const handleCopy = () => {\n    navigator.clipboard.writeText(cppCode.trim());\n    setCopied(true);\n    setTimeout(() => setCopied(false), 2000);\n  };\n\n  // Load highlight.js dynamically to avoid increasing initial bundle size\n  useEffect(() => {\n    setIsLoading(true);\n    \n    // Function to load highlight.js and its cpp language module\n    const loadHighlightJs = async () => {\n      try {\n        // Import highlight.js and its CSS\n        const hljs = await import('highlight.js/lib/core');\n        const cpp = await import('highlight.js/lib/languages/cpp');\n        const css = await import('highlight.js/styles/github.css');\n        \n        // Register the language\n        hljs.default.registerLanguage('cpp', cpp.default);\n        \n        // Highlight the code\n        const highlighted = hljs.default.highlight(cppCode, {\n          language: 'cpp',\n          ignoreIllegals: true\n        }).value;\n        \n        setHighlightedCode(highlighted);\n        setIsLoading(false);\n      } catch (error) {\n        console.error('Failed to load syntax highlighting:', error);\n        // Fallback: use the raw code without highlighting\n        setHighlightedCode(\n          cppCode.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\n/g, '<br/>')\n        );\n        setIsLoading(false);\n      }\n    };\n    \n    loadHighlightJs();\n  }, [cppCode]);\n\n  // Determine what part of the code to show\n  const displayCode = isLoading \n    ? 'Loading code...' \n    : (showFullCode \n        ? highlightedCode \n        : highlightedCode.split('// Step 8:')[0] + \"<br/><br/>// ... (more code)\");\n\n  return (\n    <div className=\"bg-white border rounded-md overflow-hidden shadow-md mb-4\">\n      <div className=\"bg-gray-100 px-4 py-2 flex items-center justify-between border-b\">\n        <div className=\"flex items-center\">\n          <Code size={20} className=\"mr-2 text-gray-700\" />\n          <span className=\"font-semibold text-gray-800\">C++ Implementation (PmergeMe.cpp)</span>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <button\n            onClick={() => setShowFullCode(!showFullCode)}\n            className=\"px-3 py-1 text-xs bg-gray-200 hover:bg-gray-300 rounded-md flex items-center\"\n          >\n            {showFullCode ? \"Show Less\" : \"Show Full Code\"}\n          </button>\n          <button\n            onClick={handleCopy}\n            className=\"px-3 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-800 rounded-md flex items-center\"\n          >\n            {copied ? <Check size={14} className=\"mr-1\" /> : <Copy size={14} className=\"mr-1\" />}\n            {copied ? \"Copied!\" : \"Copy Code\"}\n          </button>\n        </div>\n      </div>\n      \n      <div className=\"relative\">\n        {isLoading ? (\n          <div className=\"p-4 text-sm bg-gray-50 h-60 flex items-center justify-center\">\n            <div className=\"animate-pulse\">Loading syntax highlighting...</div>\n          </div>\n        ) : (\n          <pre \n            className=\"p-4 text-sm overflow-x-auto bg-gray-50 max-h-[400px] overflow-y-auto font-mono leading-relaxed hljs\"\n            dangerouslySetInnerHTML={{ __html: displayCode }}\n          />\n        )}\n      </div>\n      \n      <div className=\"bg-gray-100 px-4 py-2 border-t\">\n        <div className=\"flex justify-between items-center\">\n          <div className=\"text-xs text-gray-600\">\n            <span className=\"font-semibold\">Exercise 02:</span> PmergeMe - Ford-Johnson Algorithm C++98 Implementation\n          </div>\n          <a \n            href=\"#\" \n            className=\"text-xs text-blue-600 hover:text-blue-800 flex items-center\"\n            onClick={(e) => {\n              e.preventDefault();\n              setShowFullCode(true);\n            }}\n          >\n            {!showFullCode && <>View full implementation <ExternalLink size={12} className=\"ml-1\" /></>}\n          </a>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default CppImplementation;",
  "src/components/FordJohnsonDemo.js": "import React, { useState, useEffect } from 'react';\nimport { ChevronLeft, ChevronRight, SkipBack, SkipForward, Play, Pause, Code } from 'lucide-react';\nimport JacobsthalVisualization from './Visualization';\n\n/**\n * Enhanced Ford-Johnson Algorithm Demo\n * A self-contained, simplified visualization that can be embedded anywhere\n */\nconst FordJohnsonDemo = ({ initialArray = [5, 3, 8, 2, 1, 9, 4] }) => {\n  // State\n  const [inputArray, setInputArray] = useState(initialArray);\n  const [currentStep, setCurrentStep] = useState(0);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1.5);\n  const [steps, setSteps] = useState([]);\n  const [showJacobsthalDetail, setShowJacobsthalDetail] = useState(false);\n  \n  // Generate enhanced steps for demo when input array changes\n  useEffect(() => {\n    setSteps(generateEnhancedSteps(inputArray));\n    setCurrentStep(0);\n  }, [inputArray]);\n  \n  // Auto-play functionality\n  useEffect(() => {\n    let timer;\n    if (isPlaying && currentStep < steps.length - 1) {\n      timer = setTimeout(() => {\n        setCurrentStep(currentStep + 1);\n      }, 1000 / playbackSpeed);\n    } else if (isPlaying && currentStep >= steps.length - 1) {\n      setIsPlaying(false);\n    }\n    return () => clearTimeout(timer);\n  }, [isPlaying, currentStep, steps.length, playbackSpeed]);\n\n  // Navigation functions\n  const togglePlayback = () => setIsPlaying(!isPlaying);\n  const goToFirstStep = () => setCurrentStep(0);\n  const goToLastStep = () => setCurrentStep(steps.length - 1);\n  const goToNextStep = () => setCurrentStep(Math.min(currentStep + 1, steps.length - 1));\n  const goToPrevStep = () => setCurrentStep(Math.max(currentStep - 1, 0));\n  \n  // Get current step data\n  const currentStepData = steps[currentStep] || {\n    title: \"Loading...\",\n    description: \"Preparing algorithm steps\",\n    code: \"\",\n    memoryState: {},\n    callStack: [\"main()\"]\n  };\n  \n  // Check if current step involves Jacobsthal sequence\n  const hasJacobsthalData = currentStepData.memoryState && \n                           (currentStepData.memoryState.jacobsthal || \n                            currentStepData.title.includes(\"Jacobsthal\"));\n  \n  // Handle input change\n  const handleInputChange = (e) => {\n    const input = e.target.value.split(',').map(num => parseInt(num.trim()));\n    if (input.every(num => !isNaN(num))) {\n      setInputArray(input);\n    }\n  };\n  \n  // Render memory state visualization\n  const renderMemoryState = (memoryState) => {\n    if (!memoryState) return null;\n    \n    // Helper function to highlight active elements\n    const highlightActive = (array, activeIndices = []) => {\n      return array.map((value, idx) => (\n        <div key={idx} className=\"flex flex-col items-center mr-1 mb-1\">\n          <div className={`${activeIndices.includes(idx) ? 'ring-2 ring-red-500' : ''} \n                        px-3 py-1 rounded-md font-mono\n                        bg-purple-100 text-purple-800`}>\n            {value}\n          </div>\n          <div className=\"text-xs text-gray-500\">{idx}</div>\n        </div>\n      ));\n    };\n    \n    return (\n      <div className=\"space-y-3 p-4\">\n        {/* Operations */}\n        {memoryState.operations && memoryState.operations.length > 0 && (\n          <div className=\"bg-blue-50 p-2 rounded-md border border-blue-100 mb-3\">\n            <h4 className=\"text-sm font-semibold text-blue-800 mb-1\">Current Operations:</h4>\n            <ul className=\"list-disc list-inside text-xs space-y-1\">\n              {memoryState.operations.map((op, idx) => (\n                <li key={idx} className=\"text-gray-700\">{op}</li>\n              ))}\n            </ul>\n          </div>\n        )}\n        \n        {/* Variable Changes */}\n        {memoryState.changes && memoryState.changes.length > 0 && (\n          <div className=\"bg-green-50 p-2 rounded-md border border-green-100 mb-3\">\n            <h4 className=\"text-sm font-semibold text-green-800 mb-1\">Variable Changes:</h4>\n            {memoryState.changes.map((change, idx) => (\n              <div key={idx} className=\"flex items-center mb-1 text-xs\">\n                <span className=\"font-mono font-bold mr-2\">{change.variable}:</span>\n                <span className=\"bg-red-100 line-through px-1 py-0.5 rounded mr-1 truncate max-w-[100px]\">\n                  {change.from}\n                </span>\n                <span className=\"text-green-600\">→</span>\n                <span className=\"bg-green-100 px-1 py-0.5 rounded ml-1 truncate max-w-[100px]\">\n                  {change.to}\n                </span>\n              </div>\n            ))}\n          </div>\n        )}\n        \n        {/* Main array */}\n        {memoryState._vec !== undefined && (\n          <div className=\"flex items-center mb-3\">\n            <span className=\"font-mono font-bold mr-2 w-24\">_vec:</span>\n            <div className=\"flex flex-wrap\">\n              {memoryState._vec.length > 0 ? \n                highlightActive(memoryState._vec, memoryState.activeIndices?.vec) :\n                <div className=\"text-gray-500 italic\">empty</div>\n              }\n            </div>\n          </div>\n        )}\n        \n        {/* Straggler visualization */}\n        {memoryState.straggler !== undefined && (\n          <div className=\"flex items-center mb-3\">\n            <span className=\"font-mono font-bold mr-2 w-24\">straggler:</span>\n            <div className={`${memoryState.activeIndices?.straggler ? 'ring-2 ring-red-500' : ''} \n                            bg-yellow-100 px-3 py-1 rounded-md text-yellow-800 font-mono`}>\n              {memoryState.straggler !== null ? memoryState.straggler : 'null'}\n            </div>\n          </div>\n        )}\n        \n        {/* Pairs visualization */}\n        {memoryState.pairs && memoryState.pairs.length > 0 && (\n          <div className=\"flex items-start mb-3\">\n            <span className=\"font-mono font-bold mr-2 w-24\">pairs:</span>\n            <div className=\"flex flex-wrap\">\n              {memoryState.pairs.map((pair, idx) => (\n                <div key={idx} className=\"flex flex-col items-center mr-2 mb-2\">\n                  <div className={`${memoryState.activeIndices?.pairs === idx ? 'ring-2 ring-red-500' : ''} \n                                  bg-blue-100 px-3 py-1 rounded-md text-blue-800 font-mono flex`}>\n                    ({pair[0]}, {pair[1]})\n                  </div>\n                  <div className=\"text-xs text-gray-500\">{idx}</div>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n        \n        {/* Main chain visualization */}\n        {memoryState.mainChain && memoryState.mainChain.length > 0 && (\n          <div className=\"flex items-center mb-3\">\n            <span className=\"font-mono font-bold mr-2 w-24\">mainChain:</span>\n            <div className=\"flex flex-wrap\">\n              {memoryState.mainChain.map((value, idx) => (\n                <div key={idx} className=\"flex flex-col items-center mr-1 mb-1\">\n                  <div className={`${memoryState.activeIndices?.mainChain === idx ? 'ring-2 ring-red-500' : ''} \n                                  bg-green-100 px-3 py-1 rounded-md text-green-800 font-mono`}>\n                    {value}\n                  </div>\n                  <div className=\"text-xs text-gray-500\">{idx}</div>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n        \n        {/* Jacobsthal sequence visualization (simple version) */}\n        {memoryState.jacobsthal && memoryState.jacobsthal.length > 0 && !showJacobsthalDetail && (\n          <div className=\"flex items-center mb-3\">\n            <span className=\"font-mono font-bold mr-2 w-24\">jacobsthal:</span>\n            <div className=\"flex flex-wrap items-center\">\n              {memoryState.jacobsthal.map((value, idx) => (\n                <div key={idx} className=\"flex flex-col items-center mr-1 mb-1\">\n                  <div className={`${memoryState.activeIndices?.jacobsthal === idx ? 'ring-2 ring-red-500' : ''} \n                                  bg-indigo-100 px-3 py-1 rounded-md text-indigo-800 font-mono`}>\n                    {value}\n                  </div>\n                  <div className=\"text-xs text-gray-500\">J({idx})</div>\n                </div>\n              ))}\n              <button \n                className=\"ml-3 text-xs text-blue-600 underline\"\n                onClick={() => setShowJacobsthalDetail(true)}\n              >\n                Show detailed visualization\n              </button>\n            </div>\n          </div>\n        )}\n        \n        {/* Result visualization */}\n        {memoryState.result && (\n          <div className=\"flex items-center mb-3\">\n            <span className=\"font-mono font-bold mr-2 w-24\">result:</span>\n            <div className=\"flex flex-wrap\">\n              {memoryState.result.map((value, idx) => (\n                <div key={idx} className=\"flex flex-col items-center mr-1 mb-1\">\n                  <div className={`${memoryState.activeIndices?.result === idx ? 'ring-2 ring-red-500' : ''} \n                                  bg-red-100 px-3 py-1 rounded-md text-red-800 font-mono`}>\n                    {value}\n                  </div>\n                  <div className=\"text-xs text-gray-500\">{idx}</div>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n        \n        {/* Binary search visualization */}\n        {memoryState.binarySearch && (\n          <div className=\"bg-blue-50 p-2 rounded-md border border-blue-100 mb-3\">\n            <h4 className=\"text-sm font-semibold text-blue-800 mb-1\">Binary Search:</h4>\n            <div className=\"text-xs\">\n              <div>Searching for: <span className=\"font-mono bg-blue-100 px-1 rounded\">{memoryState.binarySearch.value}</span></div>\n              <div className=\"flex flex-wrap mt-1 mb-1\">\n                <span className=\"mr-1\">Array:</span>\n                {memoryState.binarySearch.array.map((v, i) => (\n                  <span key={i} className=\"bg-gray-100 px-1 mr-1 font-mono rounded\">{v}</span>\n                ))}\n              </div>\n              <div>Steps:</div>\n              <ul className=\"list-disc list-inside\">\n                {memoryState.binarySearch.steps.map((step, i) => (\n                  <li key={i} className=\"text-xs\">{step}</li>\n                ))}\n              </ul>\n            </div>\n          </div>\n        )}\n        \n        {/* Recursion level indicator */}\n        {memoryState.level && (\n          <div className=\"mt-2 px-3 py-1 bg-orange-100 text-orange-800 rounded-md font-semibold\">\n            {memoryState.level}\n          </div>\n        )}\n      </div>\n    );\n  };\n  \n  // Render call stack visualization\n  const renderCallStack = (callStack) => {\n    return (\n      <div className=\"border rounded-md overflow-hidden\">\n        <div className=\"bg-gray-100 px-4 py-2 text-sm font-semibold border-b\">Call Stack</div>\n        <div className=\"p-2\">\n          {callStack.slice().reverse().map((call, idx) => (\n            <div \n              key={idx} \n              className={`px-3 py-1.5 font-mono text-xs ${idx === 0 ? 'bg-green-100' : ''} ${idx > 0 ? 'border-t' : ''}`}\n            >\n              {call}\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  };\n  \n  return (\n    <div className=\"mx-auto max-w-full p-4 bg-white rounded-lg shadow-lg\">\n      <h2 className=\"text-xl font-bold mb-2\">Ford-Johnson Algorithm Demo</h2>\n      <p className=\"text-gray-600 mb-4 text-sm\">Step-by-step visualization of the merge-insert sort algorithm</p>\n      \n      {/* Input field */}\n      <div className=\"mb-4\">\n        <label className=\"block text-sm font-medium text-gray-700 mb-1\">Input Array:</label>\n        <input\n          type=\"text\"\n          className=\"w-full px-3 py-2 border rounded-md\"\n          value={inputArray.join(', ')}\n          onChange={handleInputChange}\n          placeholder=\"Enter numbers separated by commas\"\n        />\n      </div>\n      \n      {/* Controls section */}\n      <div className=\"mb-4 p-3 bg-gray-50 rounded-md shadow-sm\">\n        <div className=\"flex justify-center items-center gap-2\">\n          <button \n            onClick={goToFirstStep}\n            className=\"p-2 bg-gray-100 hover:bg-gray-200 rounded-md\"\n            title=\"First Step\"\n          >\n            <SkipBack size={16} />\n          </button>\n          <button \n            onClick={goToPrevStep}\n            className=\"p-2 bg-gray-100 hover:bg-gray-200 rounded-md\"\n            title=\"Previous Step\"\n            disabled={currentStep === 0}\n          >\n            <ChevronLeft size={16} />\n          </button>\n          <button \n            onClick={togglePlayback}\n            className=\"p-2 bg-blue-100 hover:bg-blue-200 text-blue-800 rounded-md flex items-center gap-1 px-3\"\n          >\n            {isPlaying ? <Pause size={16} /> : <Play size={16} />}\n            <span className=\"text-sm\">{isPlaying ? \"Pause\" : \"Play\"}</span>\n          </button>\n          <button \n            onClick={goToNextStep}\n            className=\"p-2 bg-gray-100 hover:bg-gray-200 rounded-md\"\n            title=\"Next Step\"\n            disabled={currentStep === steps.length - 1}\n          >\n            <ChevronRight size={16} />\n          </button>\n          <button \n            onClick={goToLastStep}\n            className=\"p-2 bg-gray-100 hover:bg-gray-200 rounded-md\"\n            title=\"Last Step\"\n          >\n            <SkipForward size={16} />\n          </button>\n          <select\n            className=\"ml-2 px-2 py-1 text-sm border rounded-md\"\n            value={playbackSpeed}\n            onChange={(e) => setPlaybackSpeed(parseFloat(e.target.value))}\n          >\n            <option value=\"0.5\">0.5x</option>\n            <option value=\"1\">1x</option>\n            <option value=\"1.5\">1.5x</option>\n            <option value=\"2\">2x</option>\n          </select>\n          <div className=\"ml-2 text-sm text-gray-700\">\n            Step {currentStep + 1} of {steps.length}\n          </div>\n        </div>\n      </div>\n      \n      {/* Step info header */}\n      <div className=\"bg-white border rounded-t-md p-3\">\n        <div className=\"flex flex-col\">\n          <h2 className=\"text-lg font-bold text-gray-800\">{currentStepData.title}</h2>\n          <p className=\"text-gray-600 text-sm\">{currentStepData.description}</p>\n          <div className=\"w-full bg-gray-200 rounded-full h-1.5 mt-2\">\n            <div \n              className=\"bg-blue-600 h-1.5 rounded-full\" \n              style={{ width: `${((currentStep + 1) / steps.length) * 100}%` }}\n            ></div>\n          </div>\n        </div>\n      </div>\n      \n      {/* Main content area */}\n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4 border rounded-md p-2 bg-white\">\n        {/* Code panel */}\n        <div className=\"md:col-span-1\">\n          <div className=\"border rounded-md overflow-hidden h-full\">\n            <div className=\"bg-gray-100 px-3 py-2 text-sm font-semibold border-b flex items-center\">\n              <Code size={16} className=\"mr-2\" /> Current Code\n            </div>\n            <pre className=\"bg-gray-50 font-mono text-xs p-3 overflow-x-auto h-48 overflow-y-auto\">\n              {currentStepData.code}\n            </pre>\n          </div>\n          \n          {/* Call stack */}\n          <div className=\"mt-3\">\n            {renderCallStack(currentStepData.callStack)}\n          </div>\n        </div>\n        \n        {/* Memory state panel */}\n        <div className=\"md:col-span-2\">\n          <div className=\"border rounded-md overflow-hidden h-full\">\n            <div className=\"bg-gray-100 px-3 py-2 text-sm font-semibold border-b\">Memory State</div>\n            <div className=\"bg-white overflow-auto h-80\">\n              {renderMemoryState(currentStepData.memoryState)}\n            </div>\n          </div>\n        </div>\n      </div>\n      \n      {/* Detailed Jacobsthal visualization */}\n      {hasJacobsthalData && showJacobsthalDetail && (\n        <div className=\"mt-4\">\n          <JacobsthalVisualization \n            jacobsthal={currentStepData.memoryState.jacobsthal} \n            insertionOrder={currentStepData.memoryState.insertionOrder}\n            activeIndex={currentStepData.memoryState.activeIndices?.insertionOrder}\n          />\n          <div className=\"flex justify-end mt-2\">\n            <button \n              className=\"text-xs text-gray-600 underline\"\n              onClick={() => setShowJacobsthalDetail(false)}\n            >\n              Hide detailed visualization\n            </button>\n          </div>\n        </div>\n      )}\n      \n      {/* Algorithm explanation */}\n      <div className=\"mt-4 p-3 bg-gray-50 rounded-md text-sm\">\n        <h3 className=\"font-semibold mb-2\">About Ford-Johnson Algorithm</h3>\n        <p className=\"mb-2\">\n          The Ford-Johnson algorithm (also known as merge-insertion sort) is designed to minimize the number of comparisons\n          needed to sort an array. It works by:\n        </p>\n        <ol className=\"list-decimal list-inside space-y-1 mb-2\">\n          <li>Grouping elements into pairs</li>\n          <li>Creating a \"main chain\" of the larger elements from each pair</li>\n          <li>Recursively sorting the main chain</li>\n          <li>Efficiently inserting the smaller elements using the Jacobsthal sequence</li>\n        </ol>\n        <p className=\"text-xs text-gray-600\">\n          This algorithm approaches the theoretical minimum number of comparisons needed for a\n          comparison-based sorting algorithm.\n        </p>\n      </div>\n    </div>\n  );\n};\n\n/**\n * Generate enhanced steps with more detailed information for each step\n * @param {Array} inputArray - The array to sort\n * @returns {Array} - Algorithm steps with detailed visualization data\n */\nfunction generateEnhancedSteps(inputArray) {\n  // Basic steps structure similar to original but with added details\n  const hasStraggler = inputArray.length % 2 !== 0;\n  const straggler = hasStraggler ? inputArray[inputArray.length - 1] : null;\n  const workingArray = hasStraggler ? inputArray.slice(0, inputArray.length - 1) : inputArray.slice();\n  \n  const steps = [];\n  \n  // Initial step\n  steps.push({\n    title: \"Initial Input\",\n    description: \"The algorithm starts with an unsorted array.\",\n    code: `// Ford-Johnson sort begins\\nsortVector([${inputArray.join(', ')}]);`,\n    memoryState: {\n      _vec: inputArray.slice(),\n      straggler: null,\n      pairs: [],\n      mainChain: [],\n      operations: [\n        \"Initialize algorithm with input array\",\n        `Array has ${inputArray.length} elements`\n      ],\n      changes: []\n    },\n    callStack: [\"main()\", \"sortVector() - Main Level\"]\n  });\n  \n  // Handle straggler\n  steps.push({\n    title: \"Handle Odd-sized Array\",\n    description: hasStraggler \n      ? \"The array has an odd number of elements, so we remove the last element as a straggler.\"\n      : \"The array has an even number of elements, so no straggler is needed.\",\n    code: hasStraggler\n      ? `// Array size is odd (${inputArray.length})\\nstraggler = _vec.back(); // ${straggler}\\n_vec.pop_back();`\n      : `// Array size is even (${inputArray.length})\\n// No straggler needed`,\n    memoryState: {\n      _vec: workingArray,\n      straggler: straggler,\n      pairs: [],\n      mainChain: [],\n      activeIndices: hasStraggler ? { straggler: true } : {},\n      operations: [\n        hasStraggler\n          ? `Detect odd-sized array (${inputArray.length} elements)`\n          : `Detect even-sized array (${inputArray.length} elements)`,\n        hasStraggler\n          ? `Extract last element ${straggler} as straggler`\n          : `No straggler extraction needed`\n      ],\n      changes: hasStraggler\n        ? [\n            { variable: \"_vec\", from: JSON.stringify(inputArray), to: JSON.stringify(workingArray) },\n            { variable: \"straggler\", from: \"null\", to: straggler.toString() }\n          ]\n        : []\n    },\n    callStack: [\"main()\", \"sortVector() - Main Level\", \"handleOddSizedArray()\"]\n  });\n  \n  // Form pairs\n  const rawPairs = [];\n  for (let i = 0; i < workingArray.length; i += 2) {\n    if (i + 1 < workingArray.length) {\n      rawPairs.push([workingArray[i], workingArray[i + 1]]);\n    }\n  }\n  \n  steps.push({\n    title: \"Form Pairs\",\n    description: \"Group elements into pairs from consecutive positions in the array.\",\n    code: `// Form pairs from consecutive elements\\nfor (size_t i = 0; i < _vec.size(); i += 2) {\\n  pair<int, int> p = make_pair(_vec[i], _vec[i+1]);\\n  pairs.push_back(p);\\n}`,\n    memoryState: {\n      _vec: workingArray,\n      straggler: straggler,\n      pairs: rawPairs,\n      mainChain: [],\n      activeIndices: { vec: Array.from({ length: workingArray.length }, (_, i) => i) },\n      operations: [\n        `Divide array into ${rawPairs.length} pairs`,\n        `Each pair contains consecutive elements from the array`\n      ],\n      changes: [\n        { variable: \"pairs\", from: \"[]\", to: JSON.stringify(rawPairs) }\n      ]\n    },\n    callStack: [\"main()\", \"sortVector() - Main Level\", \"formPairs()\"]\n  });\n  \n  // Sort within pairs\n  const sortedPairs = rawPairs.map(pair => \n    pair[0] > pair[1] ? [pair[0], pair[1]] : [pair[1], pair[0]]\n  );\n  \n  steps.push({\n    title: \"Sort Within Pairs\",\n    description: \"For each pair, ensure the larger element is first.\",\n    code: `// Sort elements within each pair\\nfor (auto& pair : pairs) {\\n  if (pair.first < pair.second)\\n    swap(pair.first, pair.second);\\n}`,\n    memoryState: {\n      _vec: workingArray,\n      straggler: straggler,\n      pairs: sortedPairs,\n      mainChain: [],\n      activeIndices: { pairs: 0 },\n      operations: [\n        `Sort elements within each pair, placing larger element first`,\n        `This ensures the main chain will contain the larger elements`\n      ],\n      changes: [\n        { variable: \"pairs\", from: JSON.stringify(rawPairs), to: JSON.stringify(sortedPairs) }\n      ]\n    },\n    callStack: [\"main()\", \"sortVector() - Main Level\", \"sortPairsInternally()\"]\n  });\n  \n  // Extract main chain\n  const mainChain = sortedPairs.map(pair => pair[0]);\n  \n  steps.push({\n    title: \"Extract Main Chain\",\n    description: \"Create the main chain from the larger elements of each pair.\",\n    code: `// Extract larger elements to form the main chain\\nfor (const auto& pair : pairs) {\\n  mainChain.push_back(pair.first);\\n}`,\n    memoryState: {\n      _vec: workingArray,\n      straggler: straggler,\n      pairs: sortedPairs,\n      mainChain: mainChain,\n      activeIndices: { \n        pairs: Array.from({ length: sortedPairs.length }, (_, i) => i),\n        mainChain: Array.from({ length: mainChain.length }, (_, i) => i)\n      },\n      operations: [\n        `Extract the larger element from each pair to form the main chain`,\n        `The main chain will be recursively sorted in the next step`\n      ],\n      changes: [\n        { variable: \"mainChain\", from: \"[]\", to: JSON.stringify(mainChain) }\n      ]\n    },\n    callStack: [\"main()\", \"sortVector() - Main Level\", \"extractMainChain()\"]\n  });\n  \n  // Main chain recursively sorted\n  const sortedMainChain = [...mainChain].sort((a, b) => a - b);\n  \n  steps.push({\n    title: \"Recursively Sort Main Chain\",\n    description: \"The main chain is recursively sorted using the same algorithm.\",\n    code: `// Recursively sort the main chain\\nif (mainChain.size() > 1) {\\n  _vec = mainChain;\\n  sortVector();\\n  mainChain = _vec;\\n}\\n// After recursion, mainChain = [${sortedMainChain.join(', ')}]`,\n    memoryState: {\n      _vec: workingArray,\n      straggler: straggler,\n      pairs: sortedPairs,\n      mainChain: sortedMainChain,\n      activeIndices: { mainChain: Array.from({ length: sortedMainChain.length }, (_, i) => i) },\n      operations: [\n        `Recursively apply Ford-Johnson sort to the main chain`,\n        `After recursion, main chain is now sorted: [${sortedMainChain.join(', ')}]`\n      ],\n      changes: [\n        { variable: \"mainChain\", from: JSON.stringify(mainChain), to: JSON.stringify(sortedMainChain) }\n      ],\n      level: \"Recursion summary\"\n    },\n    callStack: [\"main()\", \"sortVector() - Main Level\", \"sortMainChainRecursively()\"]\n  });\n  \n  // Initialize result array\n  let result = [];\n  if (sortedMainChain.length > 0) {\n    result.push(sortedMainChain[0]);\n  }\n  \n  steps.push({\n    title: \"Initialize Result\",\n    description: \"Initialize the result array with the first element from the sorted main chain.\",\n    code: `// Initialize result with first element from main chain\\nresult.push_back(mainChain[0]); // ${sortedMainChain[0] || ''}`,\n    memoryState: {\n      _vec: [],\n      straggler: straggler,\n      pairs: sortedPairs,\n      mainChain: sortedMainChain,\n      result: result,\n      activeIndices: { \n        mainChain: 0,\n        result: 0\n      },\n      operations: [\n        `Initialize result array with first element from sorted main chain`,\n        `Result array starts with: [${result.join(', ')}]`\n      ],\n      changes: [\n        { variable: \"result\", from: \"[]\", to: JSON.stringify(result) }\n      ]\n    },\n    callStack: [\"main()\", \"sortVector() - Main Level\", \"initializeResult()\"]\n  });\n  \n  // Insert first pended element\n  if (sortedPairs.length > 0) {\n    const oldResult = result.slice();\n    result.unshift(sortedPairs[0][1]);\n    \n    steps.push({\n      title: \"Insert First Smaller Element\",\n      description: \"Insert the first smaller element at the beginning of the result.\",\n      code: `// Insert first smaller element at the beginning\\nresult.insert(result.begin(), pairs[0].second); // ${sortedPairs[0]?.[1]}`,\n      memoryState: {\n        _vec: [],\n        straggler: straggler,\n        pairs: sortedPairs,\n        mainChain: sortedMainChain,\n        result: result,\n        activeIndices: { \n          pairs: 0,\n          result: 0\n        },\n        operations: [\n          `Insert first smaller element ${sortedPairs[0]?.[1]} at the beginning of result`,\n          `Result array now contains: [${result.join(', ')}]`\n        ],\n        changes: [\n          { variable: \"result\", from: JSON.stringify(oldResult), to: JSON.stringify(result) }\n        ]\n      },\n      callStack: [\"main()\", \"sortVector() - Main Level\", \"insertFirstSmaller()\"]\n    });\n  }\n  \n  // Generate Jacobsthal sequence\n  if (sortedPairs.length > 1) {\n    // Calculate Jacobsthal sequence\n    const jacobsthal = [0, 1];\n    for (let i = 2; i <= 10; i++) { // Generate up to J(10)\n      jacobsthal.push(jacobsthal[i-1] + 2 * jacobsthal[i-2]);\n    }\n    \n    steps.push({\n      title: \"Generate Jacobsthal Sequence\",\n      description: \"Generate the Jacobsthal sequence to determine the optimal insertion order.\",\n      code: `// Generate Jacobsthal sequence for optimal insertion order\\n// J(0) = 0\\n// J(1) = 1\\n// J(n) = J(n-1) + 2*J(n-2) for n ≥ 2\\n// Sequence: 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, ...`,\n      memoryState: {\n        _vec: [],\n        straggler: straggler,\n        pairs: sortedPairs,\n        mainChain: sortedMainChain,\n        result: result,\n        jacobsthal: jacobsthal,\n        operations: [\n          `Generate Jacobsthal sequence for optimal insertion order`,\n          `This sequence minimizes comparisons during insertion`,\n          `Formula: J(n) = J(n-1) + 2*J(n-2) where J(0)=0, J(1)=1`\n        ],\n        changes: [\n          { variable: \"jacobsthal\", from: \"undefined\", to: JSON.stringify(jacobsthal) }\n        ]\n      },\n      callStack: [\"main()\", \"sortVector() - Main Level\", \"generateJacobsthalSequence()\"]\n    });\n    \n    // Calculate insertion order using Jacobsthal numbers\n    const insertionOrder = [];\n    const used = new Array(sortedPairs.length).fill(false);\n    used[0] = true; // Mark first pair as already processed\n    \n    for (let i = 1; i < jacobsthal.length; i++) {\n      const idx = jacobsthal[i];\n      if (idx < sortedPairs.length && !used[idx]) {\n        insertionOrder.push(idx);\n        used[idx] = true;\n      }\n      \n      // Fill in between Jacobsthal numbers in descending order\n      for (let j = idx - 1; j > jacobsthal[i-1]; j--) {\n        if (j > 0 && j < sortedPairs.length && !used[j]) {\n          insertionOrder.push(j);\n          used[j] = true;\n        }\n      }\n    }\n    \n    // Add any remaining indices\n    for (let i = 1; i < sortedPairs.length; i++) {\n      if (!used[i]) {\n        insertionOrder.push(i);\n      }\n    }\n    \n    steps.push({\n      title: \"Determine Insertion Order\",\n      description: \"Calculate the optimal order to insert remaining elements using the Jacobsthal sequence.\",\n      code: `// Use Jacobsthal numbers to determine insertion order\\n// First insert elements at Jacobsthal indices\\n// Then fill in between in descending order\\ninsertionOrder = [${insertionOrder.join(', ')}];`,\n      memoryState: {\n        _vec: [],\n        straggler: straggler,\n        pairs: sortedPairs,\n        mainChain: sortedMainChain,\n        result: result,\n        jacobsthal: jacobsthal,\n        insertionOrder: insertionOrder,\n        operations: [\n          `Use Jacobsthal sequence to determine insertion order`,\n          `First insert elements at indices from Jacobsthal sequence`,\n          `Then fill gaps in descending order`,\n          `Final insertion order: [${insertionOrder.join(', ')}]`\n        ],\n        changes: [\n          { variable: \"insertionOrder\", from: \"[]\", to: JSON.stringify(insertionOrder) }\n        ]\n      },\n      callStack: [\"main()\", \"sortVector() - Main Level\", \"determineInsertionOrder()\"]\n    });\n    \n    // Insert remaining elements according to Jacobsthal sequence\n    let currentResult = result.slice();\n    \n    // Create individual steps for inserting each element\n    for (let i = 0; i < insertionOrder.length; i++) {\n      const idx = insertionOrder[i];\n      const mainElement = sortedMainChain[idx];\n      const smallerElement = sortedPairs[idx][1];\n      \n      // Find position for main chain element (if not already in result)\n      if (!currentResult.includes(mainElement)) {\n        let mainPos = 0;\n        while (mainPos < currentResult.length && currentResult[mainPos] < mainElement) {\n          mainPos++;\n        }\n        \n        const beforeMainInsert = currentResult.slice();\n        currentResult.splice(mainPos, 0, mainElement);\n        \n        steps.push({\n          title: `Insert Main Chain Element (${mainElement})`,\n          description: `Insert main chain element ${mainElement} from pair at index ${idx}.`,\n          code: `// Binary search to find position for mainChain[${idx}]\\npos = std::lower_bound(result.begin(), result.end(), ${mainElement});\\nresult.insert(pos, ${mainElement});`,\n          memoryState: {\n            _vec: [],\n            straggler: straggler,\n            pairs: sortedPairs,\n            mainChain: sortedMainChain,\n            result: currentResult,\n            jacobsthal: jacobsthal,\n            insertionOrder: insertionOrder,\n            activeIndices: { \n              mainChain: idx,\n              result: mainPos,\n              insertionOrder: i\n            },\n            operations: [\n              `Insert main chain element ${mainElement} from pair at index ${idx}`,\n              `Binary search finds insertion position at index ${mainPos}`,\n              `Result array: [${currentResult.join(', ')}]`\n            ],\n            changes: [\n              { \n                variable: \"result\", \n                from: JSON.stringify(beforeMainInsert), \n                to: JSON.stringify(currentResult) \n              }\n            ],\n            binarySearch: {\n              value: mainElement,\n              array: beforeMainInsert,\n              steps: [\n                `Search for position to insert ${mainElement}`,\n                `Final position: ${mainPos}`\n              ]\n            }\n          },\n          callStack: [\"main()\", \"sortVector() - Main Level\", \"insertElementsUsingFordJohnson()\"]\n        });\n      }\n      \n      // Find position for smaller element\n      let smallerPos = 0;\n      while (smallerPos < currentResult.length && currentResult[smallerPos] < smallerElement) {\n        smallerPos++;\n      }\n      \n      const beforeSmallerInsert = currentResult.slice();\n      currentResult.splice(smallerPos, 0, smallerElement);\n      \n      steps.push({\n        title: `Insert Smaller Element (${smallerElement})`,\n        description: `Insert smaller element ${smallerElement} from pair at index ${idx}.`,\n        code: `// Binary search to find position for pairs[${idx}].second\\npos = std::lower_bound(result.begin(), result.end(), ${smallerElement});\\nresult.insert(pos, ${smallerElement});`,\n        memoryState: {\n          _vec: [],\n          straggler: straggler,\n          pairs: sortedPairs,\n          mainChain: sortedMainChain,\n          result: currentResult,\n          jacobsthal: jacobsthal,\n          insertionOrder: insertionOrder,\n          activeIndices: { \n            pairs: idx,\n            result: smallerPos,\n            insertionOrder: i\n          },\n          operations: [\n            `Insert smaller element ${smallerElement} from pair at index ${idx}`,\n            `Binary search finds insertion position at index ${smallerPos}`,\n            `Result array: [${currentResult.join(', ')}]`\n          ],\n          changes: [\n            { \n              variable: \"result\", \n              from: JSON.stringify(beforeSmallerInsert), \n              to: JSON.stringify(currentResult) \n            }\n          ],\n          binarySearch: {\n            value: smallerElement,\n            array: beforeSmallerInsert,\n            steps: [\n              `Search for position to insert ${smallerElement}`,\n              `Final position: ${smallerPos}`\n            ]\n          }\n        },\n        callStack: [\"main()\", \"sortVector() - Main Level\", \"insertElementsUsingFordJohnson()\"]\n      });\n    }\n    \n    result = currentResult;\n  }\n  \n  // Insert straggler if needed\n  let finalResult = result.slice();\n  \n  if (hasStraggler) {\n    const resultBeforeStraggler = finalResult.slice();\n    \n    // Find position for straggler\n    let pos = 0;\n    while (pos < finalResult.length && finalResult[pos] < straggler) {\n      pos++;\n    }\n    \n    finalResult.splice(pos, 0, straggler);\n    \n    steps.push({\n      title: \"Insert Straggler\",\n      description: \"Insert the straggler element (if any) at the correct position.\",\n      code: `// Insert straggler element using binary search\\nif (straggler != nullptr) {\\n  auto pos = lower_bound(result.begin(), result.end(), *straggler);\\n  result.insert(pos, *straggler); // ${straggler}\\n}`,\n      memoryState: {\n        _vec: [],\n        straggler: straggler,\n        pairs: sortedPairs,\n        mainChain: sortedMainChain,\n        result: finalResult,\n        activeIndices: { \n          straggler: true,\n          result: pos\n        },\n        operations: [\n          `Insert straggler element ${straggler} using binary search`,\n          `Find correct position in the result array`,\n          `Final result contains all elements in sorted order`\n        ],\n        changes: [\n          { \n            variable: \"result\", \n            from: JSON.stringify(resultBeforeStraggler), \n            to: JSON.stringify(finalResult) \n          }\n        ],\n        binarySearch: {\n          value: straggler,\n          array: resultBeforeStraggler,\n          steps: [\n            `Search for position to insert ${straggler}`,\n            `Final position: ${pos}`\n          ]\n        }\n      },\n      callStack: [\"main()\", \"sortVector() - Main Level\", \"insertStraggler()\"]\n    });\n  }\n  \n  // Final result\n  steps.push({\n    title: \"Final Result\",\n    description: \"The array is now fully sorted using the Ford-Johnson algorithm.\",\n    code: `// Set final result and return\\n_vec = result;\\nreturn; // [${finalResult.join(', ')}]`,\n    memoryState: {\n      _vec: finalResult,\n      straggler: null,\n      pairs: [],\n      mainChain: [],\n      result: finalResult,\n      operations: [\n        `Set the final sorted result as the output array`,\n        `Ford-Johnson sort completed successfully`,\n        `Original array: [${inputArray.join(', ')}]`,\n        `Sorted array: [${finalResult.join(', ')}]`\n      ],\n      changes: [\n        { variable: \"_vec\", from: \"[]\", to: JSON.stringify(finalResult) },\n        { variable: \"straggler\", from: hasStraggler ? straggler.toString() : \"null\", to: \"null\" }\n      ]\n    },\n    callStack: [\"main()\"]\n  });\n  \n  return steps;\n}",
  "src/components/FordJohnsonVisualizer.js": "import React from 'react';\nimport { useAlgorithm } from '../hooks/useAlgorithm';\nimport { usePlayback } from '../hooks/usePlayback';\nimport { AlgorithmControls, AlgorithmStepInfo } from '../components/Algorithm';\nimport { \n  CodeVisualization, \n  MemoryStateVisualization, \n  CallStackVisualization \n} from './Visualization';\n\n/**\n * Ford-Johnson Algorithm Visualizer Component\n * Can be used independently of the main App\n */\nconst FordJohnsonVisualizer = ({ initialArray = [5, 3, 8, 2, 1, 9, 4] }) => {\n  // Use the custom hooks\n  const { \n    inputArray,\n    setInputArray,\n    currentStep, \n    currentStepData, \n    executionSteps, \n    setCurrentStep,\n    processNewInput \n  } = useAlgorithm(initialArray);\n  \n  const { \n    isPlaying, \n    playbackSpeed, \n    setPlaybackSpeed, \n    togglePlayback, \n    goToFirstStep, \n    goToLastStep, \n    goToNextStep, \n    goToPrevStep \n  } = usePlayback(currentStep, setCurrentStep, executionSteps.length);\n\n  // Handle input change\n  const handleInputChange = (e) => {\n    const input = e.target.value.split(',').map(num => parseInt(num.trim()));\n    if (input.every(num => !isNaN(num))) {\n      setInputArray(input);\n      processNewInput(input);\n    }\n  };\n\n  return (\n    <div className=\"mx-auto max-w-full p-4 bg-white rounded-lg shadow\">\n      <h2 className=\"text-xl font-bold mb-2\">Ford-Johnson Algorithm Visualizer</h2>\n      <p className=\"text-gray-600 mb-4\">Step through the execution of the merge-insert sort algorithm</p>\n      \n      {/* Algorithm Controls */}\n      <AlgorithmControls \n        inputArray={inputArray}\n        handleInputChange={handleInputChange}\n        playbackSpeed={playbackSpeed}\n        setPlaybackSpeed={setPlaybackSpeed}\n        isPlaying={isPlaying}\n        togglePlayback={togglePlayback}\n        goToFirstStep={goToFirstStep}\n        goToLastStep={goToLastStep}\n        goToNextStep={goToNextStep}\n        goToPrevStep={goToPrevStep}\n        currentStep={currentStep}\n        totalSteps={executionSteps.length}\n      />\n      \n      {/* Step Information Header */}\n      <AlgorithmStepInfo \n        title={currentStepData.title}\n        description={currentStepData.description}\n        currentStep={currentStep}\n        totalSteps={executionSteps.length}\n      />\n      \n      {/* Main Content Area */}\n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4 border-l border-r border-b rounded-b-md p-4 bg-white\">\n        {/* Code and Call Stack Panel */}\n        <div className=\"md:col-span-1 order-2 md:order-1\">\n          <CodeVisualization code={currentStepData.code} />\n          \n          <div className=\"mt-4\">\n            <CallStackVisualization callStack={currentStepData.callStack} />\n          </div>\n        </div>\n        \n        {/* Memory State Panel */}\n        <div className=\"md:col-span-2 order-1 md:order-2\">\n          <MemoryStateVisualization memoryState={currentStepData.memoryState} />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default FordJohnsonVisualizer;",
  "src/components/JacobsthalVisualization.js": "import React from 'react';\n\n/**\n * Component to visualize the Jacobsthal sequence and how it's used\n * for determining insertion order in the Ford-Johnson algorithm\n */\nconst JacobsthalVisualization = ({ jacobsthal, insertionOrder, activeIndex }) => {\n  if (!jacobsthal || jacobsthal.length === 0) return null;\n\n  // Generate Jacobsthal sequence formula steps\n  const generateFormulaSteps = (sequence, limit = 6) => {\n    const steps = [];\n    for (let i = 2; i < Math.min(sequence.length, limit); i++) {\n      steps.push(\n        <div key={i} className=\"text-xs font-mono\">\n          J({i}) = J({i-1}) + 2·J({i-2}) = {sequence[i-1]} + 2·{sequence[i-2]} = {sequence[i]}\n        </div>\n      );\n    }\n    return steps;\n  };\n\n  // Visualize how insertion order is derived from Jacobsthal sequence\n  const renderInsertionOrderDerivation = () => {\n    if (!insertionOrder || insertionOrder.length === 0) return null;\n    \n    return (\n      <div className=\"mt-3 pb-3 border-b border-gray-200\">\n        <h4 className=\"text-sm font-semibold mb-2\">Insertion Order Derivation:</h4>\n        <div className=\"flex flex-col space-y-2\">\n          <div className=\"text-xs\">\n            1. Start with the Jacobsthal numbers that are within range: \n            <span className=\"font-mono bg-yellow-100 px-1 ml-1\">\n              {jacobsthal.filter(n => n > 0 && n < 20).join(', ')}...\n            </span>\n          </div>\n          <div className=\"text-xs\">\n            2. Use these numbers as indices for insertion, filling gaps in descending order\n          </div>\n          <div className=\"text-xs flex items-center\">\n            3. Final insertion order: \n            <div className=\"flex flex-wrap ml-1\">\n              {insertionOrder.map((idx, i) => (\n                <span \n                  key={i}\n                  className={`inline-flex items-center justify-center w-6 h-6 m-0.5 rounded-full text-xs\n                    ${i === activeIndex \n                      ? 'bg-red-500 text-white ring-2 ring-red-300' \n                      : 'bg-blue-100 text-blue-800'}`\n                  }\n                >\n                  {idx}\n                </span>\n              ))}\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  // Visualize the sequence pattern graphically\n  const renderSequencePattern = () => {\n    return (\n      <div className=\"mt-3\">\n        <h4 className=\"text-sm font-semibold mb-2\">Sequence Pattern:</h4>\n        <div className=\"relative h-24 w-full bg-gray-50 rounded-md p-2 overflow-hidden\">\n          {/* Draw dots for each number */}\n          {jacobsthal.map((num, idx) => {\n            // Skip J(0) since it's 0\n            if (idx === 0) return null;\n            \n            // Calculate position (exponential scale for better visualization)\n            const xPos = (Math.log(idx + 1) / Math.log(jacobsthal.length)) * 90;\n            const yPos = 100 - (num / Math.max(...jacobsthal)) * 80;\n            \n            return (\n              <div \n                key={idx}\n                className={`absolute w-4 h-4 rounded-full flex items-center justify-center\n                  ${jacobsthal[idx] === activeIndex ? 'bg-red-500 text-white' : 'bg-blue-400 text-white'}`}\n                style={{ \n                  left: `${xPos}%`, \n                  top: `${yPos}%`,\n                  transform: 'translate(-50%, -50%)'\n                }}\n                title={`J(${idx})=${num}`}\n              >\n                <span className=\"text-xs\">{idx}</span>\n              </div>\n            );\n          })}\n          \n          {/* Draw connecting lines */}\n          <svg className=\"absolute inset-0 w-full h-full\" style={{ zIndex: 0 }}>\n            <path \n              d={jacobsthal.slice(1).map((num, idx) => {\n                const realIdx = idx + 1;\n                const xPos = (Math.log(realIdx + 1) / Math.log(jacobsthal.length)) * 90;\n                const yPos = 100 - (num / Math.max(...jacobsthal)) * 80;\n                return `${idx === 0 ? 'M' : 'L'} ${xPos}% ${yPos}%`;\n              }).join(' ')}\n              stroke=\"rgba(59, 130, 246, 0.5)\"\n              strokeWidth=\"2\"\n              fill=\"none\"\n            />\n          </svg>\n          \n          {/* Y-axis label */}\n          <div className=\"absolute left-0 top-0 h-full flex items-center\">\n            <div className=\"transform -rotate-90 text-xs text-gray-500 whitespace-nowrap\">\n              Value\n            </div>\n          </div>\n          \n          {/* X-axis label */}\n          <div className=\"absolute bottom-0 left-0 w-full text-center\">\n            <div className=\"text-xs text-gray-500\">\n              Index\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"bg-white border rounded-md overflow-hidden mt-4\">\n      <div className=\"bg-gradient-to-r from-indigo-50 to-purple-50 px-4 py-2 font-semibold border-b flex items-center justify-between\">\n        <span>Jacobsthal Sequence Visualization</span>\n        <span className=\"text-xs text-purple-600 font-normal\">\n          Optimizing insertion order\n        </span>\n      </div>\n      \n      <div className=\"p-4\">\n        <div className=\"flex flex-wrap gap-1 mb-2\">\n          {jacobsthal.map((num, idx) => (\n            <div \n              key={idx} \n              className={`flex flex-col items-center ${idx === activeIndex ? 'scale-110 transform' : ''}`}\n            >\n              <div className={`\n                px-2 py-1 rounded-md font-mono text-sm\n                ${jacobsthal[idx] === activeIndex \n                  ? 'bg-red-100 text-red-800 font-bold' \n                  : 'bg-indigo-100 text-indigo-800'}\n              `}>\n                {num}\n              </div>\n              <div className=\"text-xs text-gray-500\">J({idx})</div>\n            </div>\n          ))}\n        </div>\n        \n        <div className=\"mt-3 pb-3 border-b border-gray-200\">\n          <h4 className=\"text-sm font-semibold mb-2\">Sequence Formula:</h4>\n          <div className=\"bg-gray-50 p-2 rounded-md\">\n            <div className=\"text-xs font-mono mb-1\">J(0) = 0</div>\n            <div className=\"text-xs font-mono mb-1\">J(1) = 1</div>\n            <div className=\"text-xs font-mono mb-2\">J(n) = J(n-1) + 2·J(n-2) for n ≥ 2</div>\n            {generateFormulaSteps(jacobsthal)}\n          </div>\n        </div>\n        \n        {renderInsertionOrderDerivation()}\n        \n        {renderSequencePattern()}\n        \n        <div className=\"mt-4 bg-yellow-50 p-3 rounded-md text-sm border border-yellow-100\">\n          <h4 className=\"font-semibold text-yellow-800 mb-1\">Why Jacobsthal?</h4>\n          <p className=\"text-yellow-800 text-xs\">\n            The Jacobsthal sequence provides an optimal order for inserting elements in the Ford-Johnson algorithm.\n            It minimizes the number of comparisons needed by strategically choosing insertion positions that\n            take advantage of previously inserted elements.\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default JacobsthalVisualization;",
  "src/components/UI/Button.js": "import React from 'react';\n\n/**\n * Reusable Button component\n */\nconst Button = ({ \n  children, \n  onClick, \n  variant = 'default',  // 'default', 'primary', 'secondary', 'danger'\n  size = 'medium',      // 'small', 'medium', 'large'\n  disabled = false,\n  className = '',\n  icon = null,\n  ...props \n}) => {\n  // Variant styles\n  const variantStyles = {\n    default: 'bg-gray-100 hover:bg-gray-200 text-gray-800',\n    primary: 'bg-blue-100 hover:bg-blue-200 text-blue-800',\n    secondary: 'bg-purple-100 hover:bg-purple-200 text-purple-800',\n    danger: 'bg-red-100 hover:bg-red-200 text-red-800',\n  };\n  \n  // Size styles\n  const sizeStyles = {\n    small: 'p-1 text-sm',\n    medium: 'p-2',\n    large: 'p-3 text-lg',\n  };\n  \n  return (\n    <button\n      onClick={onClick}\n      disabled={disabled}\n      className={`\n        ${variantStyles[variant]} \n        ${sizeStyles[size]} \n        rounded-md transition-colors duration-150\n        ${disabled ? 'opacity-50 cursor-not-allowed' : ''}\n        flex items-center justify-center\n        ${className}\n      `}\n      {...props}\n    >\n      {icon && <span className=\"mr-1\">{icon}</span>}\n      {children}\n    </button>\n  );\n};\n\nexport default Button;",
  "src/components/UI/Card.js": "import React from 'react';\n\n/**\n * Reusable Card component\n */\nconst Card = ({\n  children,\n  title,\n  subtitle,\n  className = '',\n  titleClassName = '',\n  bodyClassName = '',\n  footer,\n  header,\n  ...props\n}) => {\n  return (\n    <div\n      className={`bg-white border rounded-md shadow-sm overflow-hidden ${className}`}\n      {...props}\n    >\n      {/* Optional header */}\n      {header && (\n        <div className=\"bg-gray-50 border-b px-4 py-3\">\n          {header}\n        </div>\n      )}\n      \n      {/* Title and subtitle */}\n      {(title || subtitle) && (\n        <div className={`px-4 py-3 ${header ? '' : 'border-b'} ${titleClassName}`}>\n          {title && <h3 className=\"font-semibold text-lg\">{title}</h3>}\n          {subtitle && <p className=\"text-gray-600 text-sm\">{subtitle}</p>}\n        </div>\n      )}\n      \n      {/* Card body */}\n      <div className={`p-4 ${bodyClassName}`}>\n        {children}\n      </div>\n      \n      {/* Optional footer */}\n      {footer && (\n        <div className=\"bg-gray-50 border-t px-4 py-3\">\n          {footer}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Card;",
  "src/components/UI/Input.js": "import React from 'react';\n\n/**\n * Reusable Input component\n */\nconst Input = ({\n  label,\n  name,\n  value,\n  onChange,\n  placeholder = '',\n  type = 'text',\n  error = '',\n  hint = '',\n  className = '',\n  inputClassName = '',\n  required = false,\n  ...props\n}) => {\n  return (\n    <div className={`mb-4 ${className}`}>\n      {label && (\n        <label\n          htmlFor={name}\n          className=\"block text-sm font-medium text-gray-700 mb-1\"\n        >\n          {label}\n          {required && <span className=\"text-red-500 ml-1\">*</span>}\n        </label>\n      )}\n      \n      <input\n        id={name}\n        name={name}\n        type={type}\n        value={value}\n        onChange={onChange}\n        placeholder={placeholder}\n        className={`\n          w-full px-3 py-2 border rounded-md \n          ${error ? 'border-red-300 focus:ring-red-500 focus:border-red-500' : 'border-gray-300 focus:ring-blue-500 focus:border-blue-500'} \n          focus:outline-none focus:ring-2 focus:ring-opacity-50\n          ${inputClassName}\n        `}\n        {...props}\n      />\n      \n      {error && (\n        <p className=\"mt-1 text-sm text-red-600\">{error}</p>\n      )}\n      \n      {hint && !error && (\n        <p className=\"mt-1 text-sm text-gray-500\">{hint}</p>\n      )}\n    </div>\n  );\n};\n\nexport default Input;",
  "src/components/UI/Select.js": "import React from 'react';\n\n/**\n * Reusable Select component\n */\nconst Select = ({\n  label,\n  name,\n  value,\n  onChange,\n  options = [],\n  placeholder = 'Select an option',\n  error = '',\n  hint = '',\n  className = '',\n  selectClassName = '',\n  required = false,\n  ...props\n}) => {\n  return (\n    <div className={`mb-4 ${className}`}>\n      {label && (\n        <label\n          htmlFor={name}\n          className=\"block text-sm font-medium text-gray-700 mb-1\"\n        >\n          {label}\n          {required && <span className=\"text-red-500 ml-1\">*</span>}\n        </label>\n      )}\n      \n      <select\n        id={name}\n        name={name}\n        value={value}\n        onChange={onChange}\n        className={`\n          w-full px-3 py-2 border rounded-md \n          ${error ? 'border-red-300 focus:ring-red-500 focus:border-red-500' : 'border-gray-300 focus:ring-blue-500 focus:border-blue-500'} \n          focus:outline-none focus:ring-2 focus:ring-opacity-50\n          ${selectClassName}\n        `}\n        {...props}\n      >\n        {placeholder && (\n          <option value=\"\" disabled>\n            {placeholder}\n          </option>\n        )}\n        \n        {options.map((option) => (\n          <option key={option.value} value={option.value}>\n            {option.label}\n          </option>\n        ))}\n      </select>\n      \n      {error && (\n        <p className=\"mt-1 text-sm text-red-600\">{error}</p>\n      )}\n      \n      {hint && !error && (\n        <p className=\"mt-1 text-sm text-gray-500\">{hint}</p>\n      )}\n    </div>\n  );\n};\n\nexport default Select;",
  "src/components/UI/index.js": "import Button from './Button';\nimport Card from './Card';\nimport Input from './Input';\nimport Select from './Select';\n\nexport { Button, Card, Input, Select };",
  "src/components/Visualization/ArrayVisualization.js": "import React from 'react';\n\nconst ArrayVisualization = ({ name, array, colorClass = \"bg-purple-100 text-purple-800\" }) => {\n  if (!array) return null;\n\n  return (\n    <div className=\"flex items-center\">\n      <span className=\"font-mono font-bold mr-2 w-24\">{name}:</span>\n      <div className=\"flex flex-wrap\">\n        {array.length > 0 ? (\n          array.map((value, idx) => (\n            <div key={idx} className=\"flex flex-col items-center mr-1\">\n              <div className={`${colorClass} px-3 py-1 rounded-md font-mono`}>\n                {value}\n              </div>\n              <div className=\"text-xs text-gray-500\">{idx}</div>\n            </div>\n          ))\n        ) : (\n          <div className=\"text-gray-500 italic\">empty</div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default ArrayVisualization;",
  "src/components/Visualization/BinarySearchVisualization.js": "import React from 'react';\n\nconst BinarySearchVisualization = ({ binarySearch }) => {\n  if (!binarySearch) return null;\n\n  // Extract data from the binary search object\n  const { value, array, steps } = binarySearch;\n\n  // Determine the most recent step to highlight\n  const lastStep = steps[steps.length - 1];\n  const isFound = lastStep.includes(\"Found at position\");\n  \n  // Parse the last position value\n  const positionMatch = lastStep.match(/position = (\\d+)/);\n  const position = positionMatch ? parseInt(positionMatch[1]) : null;\n\n  // Create a visualization of the array with the search space highlighted\n  const renderSearchSpace = () => {\n    return (\n      <div className=\"flex flex-col mb-4\">\n        <div className=\"text-sm font-semibold mb-2\">Search space:</div>\n        <div className=\"flex flex-wrap mb-2\">\n          {array.map((num, idx) => {\n            // Determine the appropriate styling for this cell\n            const isTarget = position === idx;\n            const cellStyle = isTarget\n              ? \"bg-green-200 border-green-400\" \n              : \"bg-gray-100 border-gray-300\";\n            \n            return (\n              <div key={idx} className=\"flex flex-col items-center mr-1 mb-1\">\n                <div className={`${cellStyle} px-3 py-1 rounded-md border font-mono relative`}>\n                  {num}\n                  {isTarget && (\n                    <div className=\"absolute -bottom-5 left-0 right-0 flex justify-center\">\n                      <div className=\"text-xs text-green-700\">\n                        {isFound ? \"Found!\" : \"Insert here\"}\n                      </div>\n                    </div>\n                  )}\n                </div>\n                <div className=\"text-xs text-gray-500 mt-2\">{idx}</div>\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  };\n\n  // Create a visualization of the binary search steps\n  const renderSteps = () => {\n    return (\n      <div className=\"mt-4\">\n        <div className=\"text-sm font-semibold mb-2\">Search steps:</div>\n        <div className=\"bg-gray-50 border border-gray-200 rounded-md p-2\">\n          <div className=\"text-sm mb-2\">\n            Searching for value: <span className=\"font-mono bg-blue-100 px-2 py-0.5 rounded-md\">{value}</span>\n          </div>\n          <ol className=\"list-decimal pl-5 space-y-1\">\n            {steps.map((step, idx) => (\n              <li key={idx} className={`font-mono text-xs ${idx === steps.length - 1 ? 'text-green-700 font-bold' : ''}`}>\n                {step}\n              </li>\n            ))}\n          </ol>\n          <div className=\"text-sm mt-3 pt-2 border-t border-gray-200\">\n            Final position: <span className=\"font-mono bg-green-100 px-2 py-0.5 rounded-md\">{position}</span>\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  // Create a visual animation of the binary search process\n  const renderSearchAnimation = () => {\n    // This function generates a visual representation of how binary search\n    // divides the search space in each step\n\n    // Parse the steps to extract left, right, and mid indices\n    const searchAnimations = steps.map(step => {\n      const midMatch = step.match(/mid=(\\d+)/);\n      if (midMatch) {\n        return {\n          mid: parseInt(midMatch[1]),\n          goLeft: step.includes(\"go left\"),\n          goRight: step.includes(\"go right\"),\n          found: step.includes(\"Found\")\n        };\n      }\n      return null;\n    }).filter(Boolean);\n\n    return (\n      <div className=\"mt-4\">\n        <div className=\"text-sm font-semibold mb-2\">Search animation:</div>\n        <div className=\"bg-gray-50 border border-gray-200 rounded-md p-3\">\n          <div className=\"flex items-center w-full h-10 relative\">\n            {/* Base bar representing the full array */}\n            <div className=\"absolute top-0 left-0 right-0 h-2 bg-gray-200 rounded-full\"></div>\n            \n            {/* Animated search divisions */}\n            {searchAnimations.map((anim, idx) => {\n              // Calculate position as percentage\n              const position = (anim.mid / (array.length - 1)) * 100;\n              const color = anim.found ? \"bg-green-500\" : \"bg-blue-500\";\n              \n              return (\n                <React.Fragment key={idx}>\n                  {/* Division marker */}\n                  <div \n                    className={`absolute top-0 h-8 border-l-2 ${color} z-10`} \n                    style={{ left: `${position}%` }}\n                  >\n                    <div className=\"absolute -top-6 -ml-3 text-xs font-mono bg-white px-1 rounded-md border\">\n                      {anim.mid}\n                    </div>\n                  </div>\n                  \n                  {/* Direction indicator */}\n                  {(anim.goLeft || anim.goRight) && (\n                    <div \n                      className={`absolute top-3 text-xs font-semibold text-${anim.goLeft ? 'blue' : 'purple'}-600`}\n                      style={{ \n                        left: `${position + (anim.goLeft ? -10 : 5)}%`,\n                        transform: anim.goLeft ? 'rotate(-45deg)' : 'rotate(45deg)'\n                      }}\n                    >\n                      {anim.goLeft ? '← left' : 'right →'}\n                    </div>\n                  )}\n                </React.Fragment>\n              );\n            })}\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"mt-6 p-3 bg-blue-50 rounded-md border border-blue-200\">\n      <div className=\"font-bold text-md mb-1\">Binary Search for {value}</div>\n      \n      {/* Search space visualization */}\n      {renderSearchSpace()}\n      \n      {/* Steps explanation */}\n      {renderSteps()}\n      \n      {/* Visual animation of the search */}\n      {array.length > 3 && renderSearchAnimation()}\n    </div>\n  );\n};\n\nexport default BinarySearchVisualization;",
  "src/components/Visualization/CallStackVisualization.js": "import React from 'react';\n\nconst CallStackVisualization = ({ callStack }) => {\n  if (!callStack || callStack.length === 0) {\n    return null;\n  }\n\n  // Reverse the call stack for display (newest on top)\n  const reversedStack = [...callStack].reverse();\n  \n  // Determine the function level depth for indentation\n  const getFunctionDepth = (funcName) => {\n    if (funcName === 'main()') return 0;\n    \n    const recursiveMatch = funcName.match(/Level (\\d+)/);\n    if (recursiveMatch) {\n      return parseInt(recursiveMatch[1]) + 1;\n    }\n    \n    // Regular functions are one level deep from their parent\n    return 1;\n  };\n  \n  // Get function type for coloring\n  const getFunctionType = (funcName) => {\n    if (funcName === 'main()') return 'main';\n    if (funcName.includes('sortVector()')) return 'sort';\n    if (funcName.includes('sortMainChain()')) return 'chain';\n    if (funcName.includes('insertElementsUsingFordJohnson()')) return 'insert';\n    if (funcName.includes('handleStragglerElement()')) return 'straggler';\n    if (funcName.includes('formSortedPairs()')) return 'pairs';\n    if (funcName.includes('extractMainChain()')) return 'extract';\n    if (funcName.includes('Binary')) return 'binary';\n    return 'other';\n  };\n  \n  // Get style for function type\n  const getFunctionStyle = (type) => {\n    const styles = {\n      main: 'bg-gray-100 text-gray-800',\n      sort: 'bg-blue-100 text-blue-800',\n      chain: 'bg-green-100 text-green-800',\n      insert: 'bg-purple-100 text-purple-800',\n      straggler: 'bg-yellow-100 text-yellow-800',\n      pairs: 'bg-indigo-100 text-indigo-800',\n      extract: 'bg-red-100 text-red-800',\n      binary: 'bg-teal-100 text-teal-800',\n      other: 'bg-gray-50 text-gray-700'\n    };\n    \n    return styles[type] || styles.other;\n  };\n\n  return (\n    <div className=\"border rounded-md overflow-hidden\">\n      <div className=\"bg-gray-100 px-4 py-2 font-semibold border-b flex items-center justify-between\">\n        <span>Call Stack</span>\n        <span className=\"text-xs text-gray-500\">Top → Bottom</span>\n      </div>\n      \n      <div className=\"bg-white p-1 max-h-[300px] overflow-auto\">\n        {reversedStack.map((call, idx) => {\n          const functionType = getFunctionType(call);\n          const depth = getFunctionDepth(call);\n          const style = getFunctionStyle(functionType);\n          \n          return (\n            <div \n              key={idx} \n              className={`px-3 py-1.5 font-mono text-sm rounded-md mb-1 flex items-center ${idx === 0 ? 'border-l-4 border-green-500' : ''}`}\n              style={{ marginLeft: `${depth * 12}px` }}\n            >\n              {/* Function indicator icon */}\n              <div className={`mr-2 w-4 h-4 flex-shrink-0 rounded-full ${style.replace('bg-', 'bg-')}`}>\n                {idx === 0 && (\n                  <div className=\"w-full h-full flex items-center justify-center text-xs\">⚡</div>\n                )}\n              </div>\n              \n              {/* Arrow for showing depth */}\n              {depth > 0 && (\n                <div className=\"text-gray-400 mr-1\">\n                  {'→'.repeat(depth)}\n                </div>\n              )}\n              \n              {/* Function name */}\n              <div className={`py-0.5 px-2 rounded-md ${style}`}>\n                {call}\n              </div>\n            </div>\n          );\n        })}\n      </div>\n      \n      {/* Legend for call stack colors */}\n      <div className=\"p-2 bg-gray-50 border-t text-xs flex flex-wrap gap-2\">\n        <div className=\"flex items-center\">\n          <div className=\"w-3 h-3 rounded-full bg-blue-100 mr-1\"></div>\n          <span>Sort</span>\n        </div>\n        <div className=\"flex items-center\">\n          <div className=\"w-3 h-3 rounded-full bg-green-100 mr-1\"></div>\n          <span>Chain</span>\n        </div>\n        <div className=\"flex items-center\">\n          <div className=\"w-3 h-3 rounded-full bg-purple-100 mr-1\"></div>\n          <span>Insert</span>\n        </div>\n        <div className=\"flex items-center\">\n          <div className=\"w-3 h-3 rounded-full bg-yellow-100 mr-1\"></div>\n          <span>Straggler</span>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default CallStackVisualization;",
  "src/components/Visualization/CodeVisualization.js": "import React from 'react';\nimport { Code } from 'lucide-react';\n\nconst CodeVisualization = ({ code }) => {\n  // Parse the code to add line numbers and highlight important parts\n  const codeWithLineNumbers = () => {\n    if (!code) return [];\n    \n    const lines = code.split('\\n');\n    \n    return lines.map((line, idx) => {\n      // Check for special comments or important statements\n      const isComment = line.trim().startsWith('//');\n      const isImportant = line.includes('mainChain') || \n                          line.includes('result') || \n                          line.includes('straggler') ||\n                          line.includes('return');\n      \n      // Handle different parts of the code with special highlighting\n      const lineClass = isComment \n                      ? 'text-gray-500 italic' \n                      : isImportant\n                      ? 'text-blue-600 font-semibold'\n                      : '';\n      \n      return (\n        <div key={idx} className=\"flex\">\n          <div className=\"w-8 flex-shrink-0 text-gray-400 select-none text-right pr-2\">\n            {idx + 1}\n          </div>\n          <pre className={`${lineClass}`}>\n            {line}\n          </pre>\n        </div>\n      );\n    });\n  };\n  \n  return (\n    <div className=\"border rounded-md overflow-hidden\">\n      <div className=\"bg-gray-100 px-4 py-2 font-semibold border-b flex items-center justify-between\">\n        <div className=\"flex items-center\">\n          <Code size={18} className=\"mr-2\" /> Current Code\n        </div>\n        <div className=\"text-xs text-gray-500\">\n          <span className=\"inline-block px-2 py-0.5 bg-blue-100 text-blue-600 rounded-md\">\n            Blue = important operations\n          </span>\n        </div>\n      </div>\n      <div className=\"bg-gray-50 font-mono text-sm p-4 overflow-x-auto max-h-[300px] overflow-y-auto\">\n        {codeWithLineNumbers()}\n      </div>\n    </div>\n  );\n};\n\nexport default CodeVisualization;",
  "src/components/Visualization/MemoryStateVisualization.js": "import React from \"react\";\nimport ArrayVisualization from \"./ArrayVisualization\";\nimport BinarySearchVisualization from \"./BinarySearchVisualization\";\n\nconst MemoryStateVisualization = ({ memoryState }) => {\n  if (!memoryState) return null;\n\n  // Highlight the current active elements in the arrays\n  const highlightActiveElements = (array, activeIndices = []) => {\n    return array.map((value, idx) => (\n      <div key={idx} className=\"flex flex-col items-center mr-1 mb-1\">\n        <div\n          className={`${\n            activeIndices.includes(idx) ? \"ring-2 ring-red-500\" : \"\"\n          } \n                         px-3 py-1 rounded-md font-mono\n                         bg-purple-100 text-purple-800`}\n        >\n          {value}\n        </div>\n        <div className=\"text-xs text-gray-500\">{idx}</div>\n      </div>\n    ));\n  };\n\n  // Variable explanations\n  const getVariableExplanations = () => {\n    const explanations = {\n      _vec: \"The current working array\",\n      straggler: \"Element removed from odd-sized array\",\n      pairs: \"Pairs formed from consecutive elements\",\n      mainChain: \"Larger elements from each pair (to be sorted)\",\n      result: \"The array being built during insertion phase\",\n      jacobsthal: \"Sequence used to optimize insertion order\",\n      insertionOrder: \"Order for inserting remaining elements\",\n    };\n\n    return (\n      <div className=\"bg-yellow-50 p-3 rounded-md border border-yellow-200 mb-4\">\n        <h3 className=\"font-semibold text-sm mb-2\">Variable Explanations:</h3>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-2 text-xs\">\n          {Object.entries(explanations).map(([key, explanation]) => (\n            <div key={key} className=\"flex\">\n              <span className=\"font-mono font-bold mr-2\">{key}:</span>\n              <span>{explanation}</span>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  };\n\n  // Get operation description\n  const getOperationDescription = () => {\n    const operations = memoryState.operations || [];\n\n    if (operations.length === 0) return null;\n\n    return (\n      <div className=\"bg-blue-50 p-3 rounded-md border border-blue-200 mb-4\">\n        <h3 className=\"font-semibold text-sm mb-2\">Current Operations:</h3>\n        <ol className=\"list-decimal list-inside text-sm\">\n          {operations.map((op, idx) => (\n            <li key={idx} className=\"mb-1\">\n              {op}\n            </li>\n          ))}\n        </ol>\n      </div>\n    );\n  };\n\n  // Visualization for variable changes\n  const getVariableChanges = () => {\n    const changes = memoryState.changes || [];\n\n    if (changes.length === 0) return null;\n\n    return (\n      <div className=\"bg-green-50 p-3 rounded-md border border-green-200 mb-4\">\n        <h3 className=\"font-semibold text-sm mb-2\">Variable Changes:</h3>\n        {changes.map((change, idx) => (\n          <div key={idx} className=\"flex items-center mb-1 text-sm\">\n            <span className=\"font-mono font-bold mr-2\">{change.variable}:</span>\n            <span className=\"bg-red-100 line-through px-2 py-0.5 rounded mr-2\">\n              {change.from}\n            </span>\n            <span className=\"text-green-600\">→</span>\n            <span className=\"bg-green-100 px-2 py-0.5 rounded ml-2\">\n              {change.to}\n            </span>\n          </div>\n        ))}\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"border rounded-md overflow-hidden h-full\">\n      <div className=\"bg-gray-100 px-4 py-2 font-semibold border-b\">\n        Memory State\n      </div>\n      <div className=\"p-4 bg-white space-y-3 overflow-auto max-h-[500px]\">\n        {/* Variable Explanations */}\n        {getVariableExplanations()}\n\n        {/* Current Operations */}\n        {getOperationDescription()}\n\n        {/* Variable Changes */}\n        {getVariableChanges()}\n\n        {/* _vec array */}\n        {memoryState._vec !== undefined && (\n          <div className=\"flex items-start\">\n            <span className=\"font-mono font-bold mr-2 w-24\">_vec:</span>\n            <div className=\"flex flex-wrap\">\n              {memoryState._vec.length > 0 ? (\n                highlightActiveElements(\n                  memoryState._vec,\n                  memoryState.activeIndices?.vec\n                )\n              ) : (\n                <div className=\"text-gray-500 italic\">empty</div>\n              )}\n            </div>\n          </div>\n        )}\n\n        {/* Straggler */}\n        {memoryState.straggler !== undefined && (\n          <div className=\"flex items-center\">\n            <span className=\"font-mono font-bold mr-2 w-24\">straggler:</span>\n            <div\n              className={`${\n                memoryState.activeIndices?.straggler\n                  ? \"ring-2 ring-red-500\"\n                  : \"\"\n              } \n                            bg-yellow-100 px-3 py-1 rounded-md text-yellow-800 font-mono`}\n            >\n              {memoryState.straggler !== null ? memoryState.straggler : \"null\"}\n            </div>\n          </div>\n        )}\n\n        {/* Pairs */}\n        {memoryState.pairs && memoryState.pairs.length > 0 && (\n          <div className=\"flex items-start\">\n            <span className=\"font-mono font-bold mr-2 w-24\">pairs:</span>\n            <div className=\"flex flex-wrap\">\n              {memoryState.pairs.map((pair, idx) => (\n                <div key={idx} className=\"flex flex-col items-center mr-2 mb-2\">\n                  <div\n                    className={`${\n                      memoryState.activeIndices?.pairs === idx\n                        ? \"ring-2 ring-red-500\"\n                        : \"\"\n                    } \n                                  bg-blue-100 px-3 py-1 rounded-md text-blue-800 font-mono flex`}\n                  >\n                    ({pair[0]}, {pair[1]})\n                  </div>\n                  <div className=\"text-xs text-gray-500\">{idx}</div>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Main Chain */}\n        {memoryState.mainChain && memoryState.mainChain.length > 0 && (\n          <div className=\"flex items-start\">\n            <span className=\"font-mono font-bold mr-2 w-24\">mainChain:</span>\n            <div className=\"flex flex-wrap\">\n              {memoryState.mainChain.map((value, idx) => (\n                <div key={idx} className=\"flex flex-col items-center mr-1 mb-1\">\n                  <div\n                    className={`${\n                      memoryState.activeIndices?.mainChain === idx\n                        ? \"ring-2 ring-red-500\"\n                        : \"\"\n                    } \n                                  bg-green-100 px-3 py-1 rounded-md text-green-800 font-mono`}\n                  >\n                    {value}\n                  </div>\n                  <div className=\"text-xs text-gray-500\">{idx}</div>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Result */}\n        {memoryState.result && (\n          <div className=\"flex items-start\">\n            <span className=\"font-mono font-bold mr-2 w-24\">result:</span>\n            <div className=\"flex flex-wrap\">\n              {memoryState.result.map((value, idx) => (\n                <div key={idx} className=\"flex flex-col items-center mr-1 mb-1\">\n                  <div\n                    className={`${\n                      memoryState.activeIndices?.result === idx\n                        ? \"ring-2 ring-red-500\"\n                        : \"\"\n                    } \n                                  bg-red-100 px-3 py-1 rounded-md text-red-800 font-mono`}\n                  >\n                    {value}\n                  </div>\n                  <div className=\"text-xs text-gray-500\">{idx}</div>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Jacobsthal Sequence */}\n        {memoryState.jacobsthal && (\n          <div className=\"flex items-start\">\n            <span className=\"font-mono font-bold mr-2 w-24\">jacobsthal:</span>\n            <div className=\"flex flex-wrap\">\n              {memoryState.jacobsthal.map((value, idx) => (\n                <div key={idx} className=\"flex flex-col items-center mr-1 mb-1\">\n                  <div\n                    className={`${\n                      memoryState.activeIndices?.jacobsthal === idx\n                        ? \"ring-2 ring-red-500\"\n                        : \"\"\n                    } \n                                  bg-indigo-100 px-3 py-1 rounded-md text-indigo-800 font-mono`}\n                  >\n                    {value}\n                  </div>\n                  <div className=\"text-xs text-gray-500\">J({idx})</div>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Insertion Order */}\n        {memoryState.insertionOrder && (\n          <div className=\"flex items-start\">\n            <span className=\"font-mono font-bold mr-2 w-24\">insertion:</span>\n            <div className=\"flex flex-wrap\">\n              {memoryState.insertionOrder.map((value, idx) => (\n                <div key={idx} className=\"flex flex-col items-center mr-1 mb-1\">\n                  <div\n                    className={`${\n                      memoryState.activeIndices?.insertionOrder === idx\n                        ? \"ring-2 ring-red-500\"\n                        : \"\"\n                    } \n                                  bg-pink-100 px-3 py-1 rounded-md text-pink-800 font-mono`}\n                  >\n                    {value}\n                  </div>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Binary Search Visualization */}\n        {memoryState.binarySearch && (\n          <BinarySearchVisualization binarySearch={memoryState.binarySearch} />\n        )}\n\n        {/* Recursion Level */}\n        {memoryState.level && (\n          <div className=\"mt-2 px-3 py-1 bg-orange-100 text-orange-800 rounded-md font-semibold\">\n            {memoryState.level}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default MemoryStateVisualization;\n",
  "src/components/Visualization/index.js": "import ArrayVisualization from './ArrayVisualization';\nimport BinarySearchVisualization from './BinarySearchVisualization';\nimport CallStackVisualization from './CallStackVisualization';\nimport CodeVisualization from './CodeVisualization';\nimport MemoryStateVisualization from './MemoryStateVisualization';\nimport JacobsthalVisualization from '../JacobsthalVisualization';\n\nexport {\n  ArrayVisualization,\n  BinarySearchVisualization,\n  CallStackVisualization,\n  CodeVisualization,\n  MemoryStateVisualization,\n  JacobsthalVisualization\n};",
  "src/components/index.js": "// Re-export all component directories\nimport FordJohnsonDemo from './FordJohnsonDemo';\nimport FordJohnsonVisualizer from './FordJohnsonVisualizer';\nimport * as Algorithm from './Algorithm';\nimport * as UI from './UI';\nimport * as Visualization from './Visualization';\n\nexport {\n  FordJohnsonDemo,\n  FordJohnsonVisualizer,\n  Algorithm,\n  UI,\n  Visualization\n};",
  "src/hooks/useAlgorithm.js": "import { useState, useEffect } from 'react';\nimport { generateAlgorithmSteps } from '../utils/algorithmSteps';\n\nexport function useAlgorithm(initialArray) {\n  const [inputArray, setInputArray] = useState(initialArray);\n  const [currentStep, setCurrentStep] = useState(0);\n  const [executionSteps, setExecutionSteps] = useState([]);\n  \n  // Generate all algorithm steps when input array changes\n  useEffect(() => {\n    const steps = generateAlgorithmSteps(inputArray);\n    setExecutionSteps(steps);\n    setCurrentStep(0);\n  }, [inputArray]);\n  \n  // Get the current step data\n  const currentStepData = executionSteps[currentStep] || {\n    title: \"Loading...\",\n    description: \"Generating algorithm steps\",\n    code: \"\",\n    memoryState: {},\n    callStack: []\n  };\n  \n  // Process a new input array\n  const processNewInput = (newArray) => {\n    const steps = generateAlgorithmSteps(newArray);\n    setExecutionSteps(steps);\n    setCurrentStep(0);\n  };\n  \n  return {\n    inputArray,\n    setInputArray,\n    currentStep,\n    setCurrentStep,\n    currentStepData,\n    executionSteps,\n    processNewInput\n  };\n}",
  "src/hooks/usePlayback.js": "import { useState, useEffect } from 'react';\n\nexport function usePlayback(currentStep, setCurrentStep, totalSteps) {\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1.5);\n  \n  // Handle automatic playback\n  useEffect(() => {\n    let timer;\n    if (isPlaying && currentStep < totalSteps - 1) {\n      timer = setTimeout(() => {\n        setCurrentStep(currentStep + 1);\n      }, 1000 / playbackSpeed);\n    } else if (isPlaying && currentStep >= totalSteps - 1) {\n      setIsPlaying(false);\n    }\n    return () => clearTimeout(timer);\n  }, [isPlaying, currentStep, totalSteps, playbackSpeed, setCurrentStep]);\n\n  // Toggle play/pause\n  const togglePlayback = () => setIsPlaying(!isPlaying);\n  \n  // Navigation functions\n  const goToFirstStep = () => setCurrentStep(0);\n  const goToLastStep = () => setCurrentStep(totalSteps - 1);\n  const goToNextStep = () => setCurrentStep(Math.min(currentStep + 1, totalSteps - 1));\n  const goToPrevStep = () => setCurrentStep(Math.max(currentStep - 1, 0));\n  \n  return {\n    isPlaying,\n    playbackSpeed,\n    setPlaybackSpeed,\n    togglePlayback,\n    goToFirstStep,\n    goToLastStep,\n    goToNextStep,\n    goToPrevStep\n  };\n}",
  "src/index.css": "body {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\ncode {\n  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',\n    monospace;\n}\n",
  "src/index.js": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\n// To use the main App:\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n\n// Uncomment this to use ExamplePage instead of App\n/*\nimport ExamplePage from './ExamplePage';\nroot.render(\n  <React.StrictMode>\n    <ExamplePage />\n  </React.StrictMode>\n);\n*/",
  "src/utils/algorithmSteps.js": "import { fordJohnsonSort } from './fordJohnson';\n\n/**\n * Generate all steps for the Ford-Johnson algorithm\n * @param {Array} inputArray - Initial array to sort\n * @returns {Array} - All algorithm execution steps\n */\nexport function generateAlgorithmSteps(inputArray) {\n  const steps = [];\n  \n  // Function to record each step\n  const recordStep = (stepData) => {\n    steps.push({\n      id: steps.length,\n      ...stepData\n    });\n  };\n  \n  // Record initial step\n  recordStep({\n    title: \"Initial Input\",\n    description: \"The algorithm starts with an unsorted array.\",\n    code: `sortVector(${JSON.stringify(inputArray)})`,\n    memoryState: {\n      _vec: inputArray.slice(),\n      straggler: null,\n      pairs: [],\n      mainChain: []\n    },\n    callStack: [\"main()\", \"sortVector() - Main Level\"]\n  });\n  \n  // Execute algorithm and record all steps\n  fordJohnsonSort(inputArray, recordStep);\n  \n  return steps;\n}",
  "src/utils/fordJohnson.js": "/**\n * Generate the Jacobsthal sequence up to n numbers\n * @param {number} n - Number of terms to generate\n * @returns {Array} - The Jacobsthal sequence\n */\nexport function getJacobsthalSequence(n) {\n    const jacobsthal = [0, 1];\n    \n    for (let i = 2; i <= n; i++) {\n      const next = jacobsthal[i-1] + 2 * jacobsthal[i-2];\n      jacobsthal.push(next);\n    }\n    \n    return jacobsthal;\n  }\n  \n  /**\n   * Binary search to find insertion position\n   * @param {Array} arr - Sorted array to search in\n   * @param {number} value - Value to insert\n   * @returns {Object} - Position and binary search steps\n   */\n  export function binarySearch(arr, value) {\n    let left = 0;\n    let right = arr.length - 1;\n    const steps = [];\n    \n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      steps.push(`mid=${mid}, arr[${mid}]=${arr[mid]}, ${value}${value > arr[mid] ? '>' : '<'}${arr[mid]}, go ${value > arr[mid] ? 'right' : 'left'}`);\n      \n      if (arr[mid] === value) {\n        steps.push(`Found at position = ${mid}`);\n        return { position: mid, steps };\n      }\n      \n      if (arr[mid] < value) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    \n    steps.push(`position = ${left}`);\n    return { position: left, steps };\n  }\n  \n  /**\n   * Ford-Johnson merge-insert sort algorithm implementation\n   * @param {Array} arr - Array to sort\n   * @param {Function} recordStep - Function to record each algorithm step\n   * @param {number} recursionLevel - Current recursion level\n   * @returns {Array} - Sorted array\n   */\n  export function fordJohnsonSort(arr, recordStep, recursionLevel = 0) {\n    const prefix = recursionLevel > 0 ? `// Recursion Level ${recursionLevel}\\n` : '';\n    const memoryPrefix = recursionLevel > 0 ? { level: `Recursion Level ${recursionLevel}` } : {};\n    \n    // Base case for recursion\n    if (arr.length <= 1) {\n      recordStep({\n        title: `${recursionLevel > 0 ? 'Recursive ' : ''}Base Case`,\n        description: \"Array has 0 or 1 elements, already sorted.\",\n        code: `${prefix}// Array size <= 1, already sorted\\nreturn ${JSON.stringify(arr)};`,\n        memoryState: {\n          ...memoryPrefix,\n          _vec: arr.slice(),\n          straggler: null,\n          pairs: [],\n          mainChain: [],\n          operations: [\n            \"Check if array size is 0 or 1\",\n            \"Since array is already sorted, return it immediately\"\n          ],\n          changes: []\n        },\n        callStack: generateCallStack(recursionLevel)\n      });\n      return arr.slice();\n    }\n    \n    recordStep({\n      title: `${recursionLevel > 0 ? 'Recursive ' : ''}Initial Input`,\n      description: `The algorithm starts with ${arr.length} elements to sort.`,\n      code: `${prefix}sortVector(${JSON.stringify(arr)})`,\n      memoryState: {\n        ...memoryPrefix,\n        _vec: arr.slice(),\n        straggler: null,\n        pairs: [],\n        mainChain: [],\n        operations: [\n          \"Initialize algorithm with input array\",\n          \"Check array size and determine next steps\"\n        ],\n        changes: []\n      },\n      callStack: generateCallStack(recursionLevel)\n    });\n    \n    // Handle odd-sized array\n    let hasStraggler = false;\n    let straggler = null;\n    let workingArr = arr.slice();\n    let operations = [];\n    let changes = [];\n    \n    if (workingArr.length % 2 !== 0) {\n      hasStraggler = true;\n      straggler = workingArr[workingArr.length - 1];\n      const oldArr = workingArr.slice();\n      workingArr = workingArr.slice(0, workingArr.length - 1);\n      \n      operations = [\n        `Detect that array size (${arr.length}) is odd`,\n        `Remove last element (${straggler}) as straggler`,\n        `Remaining array has ${workingArr.length} elements`\n      ];\n      \n      changes = [\n        { variable: \"straggler\", from: \"null\", to: straggler.toString() },\n        { variable: \"_vec\", from: JSON.stringify(oldArr), to: JSON.stringify(workingArr) }\n      ];\n      \n      recordStep({\n        title: `${recursionLevel > 0 ? 'Recursive ' : ''}Handle Odd-sized Array`,\n        description: \"If the array has an odd number of elements, remove the last element and save it as a straggler.\",\n        code: `${prefix}// Size is odd (${arr.length} elements)\\nstraggler = _vec.back(); // ${straggler}\\n_vec.pop_back();`,\n        memoryState: {\n          ...memoryPrefix,\n          _vec: workingArr.slice(),\n          straggler: straggler,\n          pairs: [],\n          mainChain: [],\n          activeIndices: { straggler: true },\n          operations,\n          changes\n        },\n        callStack: generateCallStack(recursionLevel, \"handleStragglerElement()\")\n      });\n    } else {\n      operations = [\n        `Detect that array size (${arr.length}) is even`,\n        `No need to extract straggler element`\n      ];\n      \n      recordStep({\n        title: `${recursionLevel > 0 ? 'Recursive ' : ''}Check Array Size`,\n        description: \"The array has an even number of elements, so we can directly form pairs.\",\n        code: `${prefix}// Size is even (${arr.length} elements)\\n// No straggler needed`,\n        memoryState: {\n          ...memoryPrefix,\n          _vec: workingArr.slice(),\n          straggler: null,\n          pairs: [],\n          mainChain: [],\n          operations,\n          changes: []\n        },\n        callStack: generateCallStack(recursionLevel, \"checkArraySize()\")\n      });\n    }\n    \n    // Form pairs from consecutive elements\n    const pairs = [];\n    operations = [];\n    changes = [];\n    \n    for (let i = 0; i < workingArr.length; i += 2) {\n      const first = workingArr[i];\n      const second = workingArr[i + 1];\n      \n      operations.push(`Form pair (${first}, ${second}) from indices ${i} and ${i+1}`);\n      pairs.push([first, second]);\n    }\n    \n    changes = [\n      { variable: \"pairs\", from: \"[]\", to: JSON.stringify(pairs) }\n    ];\n    \n    recordStep({\n      title: `${recursionLevel > 0 ? 'Recursive ' : ''}Form Pairs`,\n      description: \"Group elements into pairs from consecutive positions.\",\n      code: `${prefix}// Form pairs from consecutive elements\\nfor (size_t i = 0; i < _vec.size(); i += 2) {\\n  int first = _vec[i];\\n  int second = _vec[i + 1];\\n  // Store pairs\\n}`,\n      memoryState: {\n        ...memoryPrefix,\n        _vec: workingArr.slice(),\n        straggler: straggler,\n        pairs: pairs.map(pair => pair.slice()),\n        mainChain: [],\n        activeIndices: { vec: Array.from(Array(workingArr.length).keys()) },\n        operations,\n        changes\n      },\n      callStack: generateCallStack(recursionLevel, \"formSortedPairs()\")\n    });\n    \n    // Sort elements within each pair\n    const sortedPairs = [];\n    operations = [];\n    changes = [];\n    \n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i];\n      let sortedPair;\n      \n      if (pair[0] > pair[1]) {\n        sortedPair = [pair[0], pair[1]];\n        operations.push(`Pair ${i}: ${pair[0]} > ${pair[1]}, keep order (${pair[0]}, ${pair[1]})`);\n      } else {\n        sortedPair = [pair[1], pair[0]];\n        operations.push(`Pair ${i}: ${pair[0]} < ${pair[1]}, swap to (${pair[1]}, ${pair[0]})`);\n      }\n      \n      sortedPairs.push(sortedPair);\n    }\n    \n    changes = [\n      { variable: \"pairs\", from: JSON.stringify(pairs), to: JSON.stringify(sortedPairs) }\n    ];\n    \n    recordStep({\n      title: `${recursionLevel > 0 ? 'Recursive ' : ''}Sort Within Pairs`,\n      description: \"For each pair, ensure the larger element is first.\",\n      code: `${prefix}// Sort elements within each pair\\nif (first > second)\\n  pairs.push_back(std::make_pair(first, second));\\nelse\\n  pairs.push_back(std::make_pair(second, first));`,\n      memoryState: {\n        ...memoryPrefix,\n        _vec: workingArr.slice(),\n        straggler: straggler,\n        pairs: sortedPairs.map(pair => pair.slice()),\n        mainChain: [],\n        activeIndices: { pairs: 0 },\n        operations,\n        changes\n      },\n      callStack: generateCallStack(recursionLevel, \"formSortedPairs()\")\n    });\n    \n    // Extract main chain (larger elements from each pair)\n    const mainChain = [];\n    operations = [];\n    changes = [];\n    \n    for (let i = 0; i < sortedPairs.length; i++) {\n      const largerElement = sortedPairs[i][0];\n      mainChain.push(largerElement);\n      operations.push(`Extract larger element ${largerElement} from pair ${i}`);\n    }\n    \n    changes = [\n      { variable: \"mainChain\", from: \"[]\", to: JSON.stringify(mainChain) }\n    ];\n    \n    recordStep({\n      title: `${recursionLevel > 0 ? 'Recursive ' : ''}Extract Main Chain`,\n      description: \"Create the main chain from the larger elements of each pair.\",\n      code: `${prefix}// Extract larger elements to form main chain\\nfor (size_t i = 0; i < pairs.size(); i++) {\\n  mainChain.push_back(pairs[i].first);\\n}`,\n      memoryState: {\n        ...memoryPrefix,\n        _vec: workingArr.slice(),\n        straggler: straggler,\n        pairs: sortedPairs.map(pair => pair.slice()),\n        mainChain: mainChain.slice(),\n        activeIndices: { \n          mainChain: null,\n          pairs: Array.from(Array(sortedPairs.length).keys())\n        },\n        operations,\n        changes\n      },\n      callStack: generateCallStack(recursionLevel, \"extractMainChain()\")\n    });\n    \n    // Recursively sort main chain\n    let sortedMainChain = mainChain.slice();\n    \n    if (mainChain.length > 1) {\n      operations = [\n        `Main chain has ${mainChain.length} elements and needs to be sorted`,\n        `Prepare for recursive sorting of main chain`\n      ];\n      \n      changes = [\n        { variable: \"_vec\", from: JSON.stringify(workingArr), to: JSON.stringify(mainChain) }\n      ];\n      \n      recordStep({\n        title: `${recursionLevel > 0 ? 'Recursive ' : ''}Prepare Recursive Call`,\n        description: \"Recursively sort the main chain by reassigning it to _vec and calling sortVector again.\",\n        code: `${prefix}// Recursively sort main chain\\nif (mainChain.size() > 1) {\\n  _vec = mainChain;\\n  sortVector();\\n  mainChain = _vec;\\n}`,\n        memoryState: {\n          ...memoryPrefix,\n          _vec: mainChain.slice(),\n          straggler: straggler,\n          pairs: sortedPairs.map(pair => pair.slice()),\n          mainChain: mainChain.slice(),\n          activeIndices: { mainChain: Array.from(Array(mainChain.length).keys()) },\n          operations,\n          changes\n        },\n        callStack: generateCallStack(recursionLevel, \"sortMainChain()\")\n      });\n      \n      // Recursive call\n      sortedMainChain = fordJohnsonSort(mainChain, recordStep, recursionLevel + 1);\n      \n      operations = [\n        `Received sorted main chain from recursive call`,\n        `Update main chain with sorted result`\n      ];\n      \n      changes = [\n        { variable: \"mainChain\", from: JSON.stringify(mainChain), to: JSON.stringify(sortedMainChain) }\n      ];\n      \n      recordStep({\n        title: `${recursionLevel > 0 ? 'Recursive ' : ''}Main Chain Sorted`,\n        description: \"Received sorted main chain from recursive call.\",\n        code: `${prefix}// Main chain sorted by recursive call\\nmainChain = ${JSON.stringify(sortedMainChain)};`,\n        memoryState: {\n          ...memoryPrefix,\n          _vec: workingArr.slice(),\n          straggler: straggler,\n          pairs: sortedPairs.map(pair => pair.slice()),\n          mainChain: sortedMainChain.slice(),\n          activeIndices: { mainChain: Array.from(Array(sortedMainChain.length).keys()) },\n          operations,\n          changes\n        },\n        callStack: generateCallStack(recursionLevel)\n      });\n    } else if (mainChain.length === 1) {\n      operations = [\n        `Main chain has only 1 element, already sorted`,\n        `No need for recursive sorting`\n      ];\n      \n      recordStep({\n        title: `${recursionLevel > 0 ? 'Recursive ' : ''}Skip Recursive Call`,\n        description: \"Main chain has only one element, so it's already sorted.\",\n        code: `${prefix}// Main chain has only one element\\n// Skip recursive call, already sorted`,\n        memoryState: {\n          ...memoryPrefix,\n          _vec: workingArr.slice(),\n          straggler: straggler,\n          pairs: sortedPairs.map(pair => pair.slice()),\n          mainChain: sortedMainChain.slice(),\n          activeIndices: { mainChain: 0 },\n          operations,\n          changes: []\n        },\n        callStack: generateCallStack(recursionLevel, \"checkMainChainSize()\")\n      });\n    }\n    \n    // Initialize result with first element from sorted main chain\n    let result = [];\n    operations = [];\n    changes = [];\n    \n    if (sortedMainChain.length > 0) {\n      result.push(sortedMainChain[0]);\n      \n      operations = [\n        `Initialize result array with first element from sorted main chain: ${sortedMainChain[0]}`\n      ];\n      \n      changes = [\n        { variable: \"result\", from: \"[]\", to: JSON.stringify(result) }\n      ];\n      \n      recordStep({\n        title: `${recursionLevel > 0 ? 'Recursive ' : ''}Initialize Result`,\n        description: \"Begin insertion phase by initializing result with first main chain element.\",\n        code: `${prefix}// Initialize result\\nresult.push_back(mainChain[0]); // ${sortedMainChain[0]}`,\n        memoryState: {\n          ...memoryPrefix,\n          _vec: [],\n          straggler: straggler,\n          pairs: sortedPairs.map(pair => pair.slice()),\n          mainChain: sortedMainChain.slice(),\n          result: result.slice(),\n          activeIndices: { \n            mainChain: 0,\n            result: 0\n          },\n          operations,\n          changes\n        },\n        callStack: generateCallStack(recursionLevel, \"insertElementsUsingFordJohnson()\")\n      });\n    }\n    \n    // Insert first smaller element at beginning\n    if (sortedPairs.length > 0) {\n      const oldResult = result.slice();\n      result.unshift(sortedPairs[0][1]);\n      \n      operations = [\n        `Insert first smaller element (${sortedPairs[0][1]}) at beginning of result`\n      ];\n      \n      changes = [\n        { variable: \"result\", from: JSON.stringify(oldResult), to: JSON.stringify(result) }\n      ];\n      \n      recordStep({\n        title: `${recursionLevel > 0 ? 'Recursive ' : ''}Insert First Smaller Element`,\n        description: \"Insert the first smaller element at the beginning of the result.\",\n        code: `${prefix}// Insert first smaller element\\nresult.insert(result.begin(), pairs[0].second); // ${sortedPairs[0][1]}`,\n        memoryState: {\n          ...memoryPrefix,\n          _vec: [],\n          straggler: straggler,\n          pairs: sortedPairs.map(pair => pair.slice()),\n          mainChain: sortedMainChain.slice(),\n          result: result.slice(),\n          activeIndices: { \n            pairs: 0,\n            result: 0\n          },\n          operations,\n          changes\n        },\n        callStack: generateCallStack(recursionLevel, \"insertElementsUsingFordJohnson()\")\n      });\n    }\n    \n    // For remaining elements, use Jacobsthal sequence for insertion order\n    if (sortedPairs.length > 1) {\n      // Generate Jacobsthal sequence for insertion order\n      let jacobsthalSize = 3;\n      while (getJacobsthalSequence(jacobsthalSize).slice(-1)[0] < sortedPairs.length) {\n        jacobsthalSize++;\n      }\n      \n      const jacobSeq = getJacobsthalSequence(jacobsthalSize);\n      operations = [\n        `Generate Jacobsthal sequence for optimized insertion order`,\n        `Sequence: ${jacobSeq.slice(0, 6).join(', ')}${jacobSeq.length > 6 ? '...' : ''}`\n      ];\n      \n      changes = [\n        { variable: \"jacobsthal\", from: \"undefined\", to: JSON.stringify(jacobSeq.slice(0, jacobsthalSize)) }\n      ];\n      \n      recordStep({\n        title: `${recursionLevel > 0 ? 'Recursive ' : ''}Generate Jacobsthal Sequence`,\n        description: \"Generate the Jacobsthal sequence to determine insertion order.\",\n        code: `${prefix}// Generate Jacobsthal sequence\\nJ(0) = 0, J(1) = 1, J(2) = 1, J(3) = 3, ...\\n// For ${sortedPairs.length} pairs, need indices: ${jacobSeq.filter(n => n > 0 && n < sortedPairs.length).join(', ')}`,\n        memoryState: {\n          ...memoryPrefix,\n          _vec: [],\n          straggler: straggler,\n          pairs: sortedPairs.map(pair => pair.slice()),\n          mainChain: sortedMainChain.slice(),\n          result: result.slice(),\n          jacobsthal: jacobSeq.slice(0, jacobsthalSize),\n          insertionOrder: [],\n          activeIndices: {},\n          operations,\n          changes\n        },\n        callStack: generateCallStack(recursionLevel, \"insertElementsUsingFordJohnson()\", \"generateInsertionOrder()\")\n      });\n      \n      // Fill insertion order using Jacobsthal numbers\n      const insertionOrder = [];\n      const inserted = new Array(sortedPairs.length).fill(false);\n      inserted[0] = true; // Mark first pair as already inserted\n      \n      for (let i = 1; i < jacobSeq.length && jacobSeq[i] < sortedPairs.length; i++) {\n        const idx = jacobSeq[i];\n        if (!inserted[idx]) {\n          insertionOrder.push(idx);\n          inserted[idx] = true;\n        }\n        \n        // Insert elements between consecutive Jacobsthal numbers in descending order\n        for (let j = idx - 1; j > jacobSeq[i-1]; j--) {\n          if (j >= 0 && j < sortedPairs.length && !inserted[j]) {\n            insertionOrder.push(j);\n            inserted[j] = true;\n          }\n        }\n      }\n      \n      // Add any remaining indices\n      for (let i = 1; i < sortedPairs.length; i++) {\n        if (!inserted[i]) {\n          insertionOrder.push(i);\n        }\n      }\n      \n      operations = [\n        `Calculate optimal insertion order based on Jacobsthal sequence`,\n        `Insertion order: ${insertionOrder.join(', ')}`\n      ];\n      \n      changes = [\n        { variable: \"insertionOrder\", from: \"[]\", to: JSON.stringify(insertionOrder) }\n      ];\n      \n      recordStep({\n        title: `${recursionLevel > 0 ? 'Recursive ' : ''}Determine Insertion Order`,\n        description: \"Using Jacobsthal sequence to determine the optimal insertion order for efficiency.\",\n        code: `${prefix}// Determine insertion order\\ninsertionOrder = ${JSON.stringify(insertionOrder)};`,\n        memoryState: {\n          ...memoryPrefix,\n          _vec: [],\n          straggler: straggler,\n          pairs: sortedPairs.map(pair => pair.slice()),\n          mainChain: sortedMainChain.slice(),\n          result: result.slice(),\n          jacobsthal: jacobSeq.slice(0, jacobsthalSize),\n          insertionOrder: insertionOrder.slice(),\n          activeIndices: { insertionOrder: Array.from(Array(insertionOrder.length).keys()) },\n          operations,\n          changes\n        },\n        callStack: generateCallStack(recursionLevel, \"insertElementsUsingFordJohnson()\")\n      });\n      \n      // Insert elements according to Jacobsthal sequence\n      for (let i = 0; i < insertionOrder.length; i++) {\n        const idx = insertionOrder[i];\n        operations = [];\n        changes = [];\n        \n        // Insert main chain element\n        const mainChainElement = sortedMainChain[idx];\n        const oldResult = result.slice();\n        const mainChainSearch = binarySearch(result, mainChainElement);\n        const mainChainPos = mainChainSearch.position;\n        result.splice(mainChainPos, 0, mainChainElement);\n        \n        operations = [\n          `Insert main chain element ${mainChainElement} from index ${idx}`,\n          `Binary search to find position: ${mainChainSearch.steps.join(' → ')}`,\n          `Insert at position ${mainChainPos} in result array`\n        ];\n        \n        changes = [\n          { variable: \"result\", from: JSON.stringify(oldResult), to: JSON.stringify(result) }\n        ];\n        \n        recordStep({\n          title: `${recursionLevel > 0 ? 'Recursive ' : ''}Insert Main Chain Element (Idx ${idx})`,\n          description: `Insert main chain element at index ${idx} using binary search.`,\n          code: `${prefix}// Binary search to find position for mainChain[${idx}]\\npos = std::lower_bound(result.begin(), result.end(), mainChain[${idx}]); // ${mainChainElement}\\nresult.insert(pos, mainChain[${idx}]);`,\n          memoryState: {\n            ...memoryPrefix,\n            _vec: [],\n            straggler: straggler,\n            pairs: sortedPairs.map(pair => pair.slice()),\n            mainChain: sortedMainChain.slice(),\n            result: result.slice(),\n            insertionOrder: insertionOrder.slice(),\n            activeIndices: { \n              mainChain: idx,\n              result: mainChainPos,\n              insertionOrder: i\n            },\n            operations,\n            changes,\n            binarySearch: {\n              value: mainChainElement,\n              array: oldResult,\n              steps: mainChainSearch.steps\n            }\n          },\n          callStack: generateCallStack(recursionLevel, \"insertElementsUsingFordJohnson()\")\n        });\n        \n        // Insert smaller element\n        const smallerElement = sortedPairs[idx][1];\n        const oldResult2 = result.slice();\n        const smallerSearch = binarySearch(result, smallerElement);\n        const smallerPos = smallerSearch.position;\n        result.splice(smallerPos, 0, smallerElement);\n        \n        operations = [\n          `Insert smaller element ${smallerElement} from pair at index ${idx}`,\n          `Binary search to find position: ${smallerSearch.steps.join(' → ')}`,\n          `Insert at position ${smallerPos} in result array`\n        ];\n        \n        changes = [\n          { variable: \"result\", from: JSON.stringify(oldResult2), to: JSON.stringify(result) }\n        ];\n        \n        recordStep({\n          title: `${recursionLevel > 0 ? 'Recursive ' : ''}Insert Smaller Element (Idx ${idx})`,\n          description: `Insert smaller element from pair at index ${idx} using binary search.`,\n          code: `${prefix}// Binary search to find position for pairs[${idx}].second\\npos = std::lower_bound(result.begin(), result.end(), pairs[${idx}].second); // ${smallerElement}\\nresult.insert(pos, pairs[${idx}].second);`,\n          memoryState: {\n            ...memoryPrefix,\n            _vec: [],\n            straggler: straggler,\n            pairs: sortedPairs.map(pair => pair.slice()),\n            mainChain: sortedMainChain.slice(),\n            result: result.slice(),\n            insertionOrder: insertionOrder.slice(),\n            activeIndices: { \n              pairs: idx,\n              result: smallerPos,\n              insertionOrder: i\n            },\n            operations,\n            changes,\n            binarySearch: {\n              value: smallerElement,\n              array: oldResult2,\n              steps: smallerSearch.steps\n            }\n          },\n          callStack: generateCallStack(recursionLevel, \"insertElementsUsingFordJohnson()\")\n        });\n      }\n    }\n    \n    // Insert straggler if exists\n    if (hasStraggler) {\n      const oldResult = result.slice();\n      const stragglerSearch = binarySearch(result, straggler);\n      const stragglerPos = stragglerSearch.position;\n      result.splice(stragglerPos, 0, straggler);\n      \n      operations = [\n        `Insert straggler element ${straggler}`,\n        `Binary search to find position: ${stragglerSearch.steps.join(' → ')}`,\n        `Insert at position ${stragglerPos} in result array`\n      ];\n      \n      changes = [\n        { variable: \"result\", from: JSON.stringify(oldResult), to: JSON.stringify(result) }\n      ];\n      \n      recordStep({\n        title: `${recursionLevel > 0 ? 'Recursive ' : ''}Insert Straggler`,\n        description: \"Insert the straggler element at the correct position using binary search.\",\n        code: `${prefix}// Insert straggler\\npos = std::lower_bound(result.begin(), result.end(), straggler); // ${straggler}\\nresult.insert(pos, straggler);`,\n        memoryState: {\n          ...memoryPrefix,\n          _vec: [],\n          straggler: straggler,\n          pairs: sortedPairs.map(pair => pair.slice()),\n          mainChain: sortedMainChain.slice(),\n          result: result.slice(),\n          activeIndices: { \n            straggler: true,\n            result: stragglerPos\n          },\n          operations,\n          changes,\n          binarySearch: {\n            value: straggler,\n            array: oldResult,\n            steps: stragglerSearch.steps\n          }\n        },\n        callStack: generateCallStack(recursionLevel, \"insertElementsUsingFordJohnson()\")\n      });\n    }\n    \n    // Return sorted result\n    operations = [\n      `Set final result as the output vector`,\n      `Algorithm completed successfully`\n    ];\n    \n    changes = [\n      { variable: \"_vec\", from: \"[]\", to: JSON.stringify(result) }\n    ];\n    \n    recordStep({\n      title: `${recursionLevel > 0 ? 'Return From Recursion Level ' + recursionLevel : 'Return Final Result'}`,\n      description: `Set _vec to the final sorted result${recursionLevel > 0 ? ' and return to previous recursion level' : ' and return'}.`,\n      code: `${prefix}// Set _vec to final result\\n_vec = result;\\n// Return ${recursionLevel > 0 ? 'to previous level' : 'to main'}`,\n      memoryState: {\n        ...memoryPrefix,\n        _vec: result.slice(),\n        straggler: null,\n        pairs: [],\n        mainChain: [],\n        result: result.slice(),\n        operations,\n        changes\n      },\n      callStack: recursionLevel > 0 ? generateCallStack(recursionLevel - 1, \"sortMainChain()\") : [\"main()\"]\n    });\n    \n    return result;\n  }\n  \n  /**\n   * Generate the call stack based on recursion level\n   * @param {number} recursionLevel - Current recursion level\n   * @param {string} currentFunction - Current function being executed\n   * @param {string} subFunction - Sub-function being executed if any\n   * @returns {Array} - Call stack representation\n   */\n  function generateCallStack(recursionLevel, currentFunction = \"\", subFunction = \"\") {\n    const callStack = [\"main()\"];\n    \n    // Add main level\n    callStack.push(\"sortVector() - Main Level\");\n    \n    // Add recursive levels\n    for (let i = 1; i <= recursionLevel; i++) {\n      callStack.push(`sortMainChain() - Level ${i-1}`);\n      callStack.push(`sortVector() - Recursive Level ${i}`);\n    }\n    \n    // Add current function\n    if (currentFunction) {\n      callStack.push(currentFunction);\n      \n      // Add sub-function if present\n      if (subFunction) {\n        callStack.push(subFunction);\n      }\n    }\n    \n    return callStack;\n  }",
  "src/utils/jacobsthal.js": "/**\n * Calculate the Jacobsthal sequence\n * Jacobsthal numbers: 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, ...\n * Formula: J(n) = J(n-1) + 2*J(n-2) with J(0)=0, J(1)=1\n * Used in merge-insertion sort to optimize insertion order\n */\nexport function getJacobsthalSequence(n) {\n    if (n <= 0) return [0];\n    if (n === 1) return [0, 1];\n    \n    // Initialize with first two elements\n    const sequence = [0, 1];\n    \n    // Calculate subsequent elements\n    for (let i = 2; i <= n; i++) {\n      const nextValue = sequence[i-1] + 2 * sequence[i-2];\n      sequence.push(nextValue);\n    }\n    \n    return sequence;\n  }\n  \n  /**\n   * Calculate the insertion order for merge-insert sort based on Jacobsthal sequence\n   * @param {number} size - The number of elements to create insertion order for\n   * @returns {Array} - Optimal insertion order based on Jacobsthal sequence\n   */\n  export function calculateInsertionOrder(size) {\n    // If size is 0 or 1, no insertion needed\n    if (size <= 1) return [];\n    \n    // Generate Jacobsthal sequence large enough to cover size\n    let jacobsthalSize = 3;\n    while (getJacobsthalSequence(jacobsthalSize).slice(-1)[0] < size) {\n      jacobsthalSize++;\n    }\n    \n    const jacobSeq = getJacobsthalSequence(jacobsthalSize);\n    const insertionOrder = [];\n    const inserted = new Array(size).fill(false);\n    inserted[0] = true; // First element already in result\n    \n    // Use Jacobsthal numbers to determine insertion order\n    for (let i = 1; i < jacobSeq.length && jacobSeq[i] < size; i++) {\n      const idx = jacobSeq[i];\n      if (!inserted[idx]) {\n        insertionOrder.push(idx);\n        inserted[idx] = true;\n      }\n      \n      // Fill in intermediate values in descending order\n      for (let j = idx - 1; j > jacobSeq[i-1]; j--) {\n        if (j >= 0 && j < size && !inserted[j]) {\n          insertionOrder.push(j);\n          inserted[j] = true;\n        }\n      }\n    }\n    \n    // Add any remaining uninserted indices\n    for (let i = 1; i < size; i++) {\n      if (!inserted[i]) {\n        insertionOrder.push(i);\n      }\n    }\n    \n    return insertionOrder;\n  }"
}